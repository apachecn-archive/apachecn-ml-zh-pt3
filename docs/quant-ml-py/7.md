# 7.量子变分优化和绝热方法

> *“宇宙的历史，实际上是一场巨大的正在进行的量子计算。宇宙是一台量子计算机。”*
> 
> —塞斯劳埃德

在这一章中，我们将看一看在公式中使用量子计算的各种优化技术。我们将要详细研究的几个这样的算法是变分量子本征解算器，通常称为 VQE，和量子近似优化算法，也称为 QAOA。这两种方法的中心思想是将成本目标定义为与量子系统相关的适当哈密顿量的期望。基于最大化或最小化问题，我们期望通过这些优化技术得到最大或最小特征值状态。这两种方法都是变分的，因为它们结合了量子和经典的优化方法。因为这个主题是围绕哈密顿量展开的，所以我们也将在本章研究流行的 Isling 哈密顿量模型。类似地，QAOA 技术是基于量子系统的绝热演化，因此我们将在这一章详细研究它的数学基础。

作为对 VQE 的应用，我们实现了图聚类的量子最大割算法。最后，我们通过研究图量子随机游走算法来结束这一章。这一章中所有的优化技术都是近似的，因此它们非常适合有噪声的近期量子计算机。事不宜迟，让我们从变分量子本征解算器开始。

## 变分量子特征解算器

变分量子本征解算器是一种量子计算算法，非常适合于解决优化问题，其中目标可以根据量子系统的哈密顿量来定义。哈密顿量代表量子系统在不同量子基态下的能量，我们感兴趣的是具有最小能量的基态。处于∣ *ψ* ⟩态的量子系统的期望能量与哈密顿量 *H* 由哈密顿算符的期望给出如下:

![$$ \left\langle H\right\rangle =\left\langle \psi \left|H\right|\psi \right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ1.png)

(7-1)

在变分量子本征解算器中，我们要选择使哈密顿量能量最小化的状态|*ψ*<sup>∫</sup>⟩如下所示:

![$$ \left|{\psi}^{\ast}\right\rangle =\mathit{\arg}\ \underset{\psi }{\min}\left\langle \psi \left|H\right|\psi \right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ2.png)

(7-2)

因为量子系统的哈密顿量本质上是厄米的，所以它具有谱分解，其中特征向量形成正交基，并且特征值是实数。哈密顿量的本征值代表量子系统在相应本征态下的能量，由于它们是实数，因此可以按如下顺序排列:

![$$ {\lambda}_0\le {\lambda}_1\le {\lambda}_2\le \dots {\lambda}_{n-1} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ3.png)

(7-3)

不难看出，最小哈密顿量能量等于最低本征值*λ*T2】0 并发生在最低本征值*λ*T10】0 对应的本征态|*ϕ*T6】0⟩。为了从数学上推导出这一点，我们可以将方程 [7-1](#Equ1) 中的目标最小化，并限制基态是根据量子态的范数的单位*1*2<sup>2</sup>范数。

![$$ \underset{\psi }{\min}\left\langle \psi \left|H\right|\psi \right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equa.png)

服从⟨ *ψ* | *ψ* ⟩ = 1 (7-4)

我们可以使用拉格朗日乘数 *λ* 将约束组合到主目标，如下所示:

![$$ L\left(\psi \right)=\left\langle \psi |H\mid \psi \right\rangle -\lambda \left\langle \psi \right|\psi \Big\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ4.png)

(7-5)

为了最小化目标 *L* ( *ψ* )，我们可以取其相对于状态向量∣ *ψ* ⟩的梯度，并将其设置为零，如下所示:

![$$ {\nabla}_{\psi }L=2H\left|\psi \right\rangle -2\lambda \left|\psi \right\rangle =0 $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equb.png)

![$$ \to H\left|\psi \right\rangle =\lambda \mid \psi \Big\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ5.png)

(7-6)

方程式 [7-6](#Equ5) 告诉我们最小能态是哈密顿量 *H* 的一个特征向量，但我们还不知道具体是哪一个。如前所述，哈密顿量有一个谱分解，其中特征向量是正交的，特征值是实数。这允许我们将哈密顿量 *H* 写成如下:

![$$ H=\sum \limits_{i=0}^{n-1}{\lambda}_i\mid {\phi}_i\left\rangle \right\langle {\phi}_i\mid $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ6.png)

(7-7)

要最小化的量，⟨*ψ*|*h*|*ψ*⟩，可以根据等式 [7-7](#Equ6) 中的频谱分解写成如下:

![$$ \left\langle \psi \left|H\right|\psi \right\rangle =\sum \limits_{i=0}^{n-1}{\lambda}_i\left\langle \psi |{\phi}_i\right\rangle \left\langle {\phi}_i|\psi \right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ7.png)

(7-8)

我们已经推导出，∣ *ψ* ⟩必定是特征向量之一∣*ϕ*<sub>t5】I</sub>⟩.从方程 [7-8](#Equ8) 我们可以看到，当我们选择|*ψ*⟩=∣*ϕ*<sub>*o*</sub>⟩时，⟨*ψ*|*h*|*ψ*⟩最小化，在这种情况下，哈密顿量的能量变成了 *λ* <sub>*o*</sub>

因此，在量子变分本征解算器中，我们试图通过首先将优化目标公式化为合适的哈密顿量，然后求解对应于哈密顿量的最低本征值的本征向量来解决最小化问题。试图通过结合量子计算和经典计算步骤来求解对应于最低特征值的特征向量的方法，因此该技术属于变分方法的范畴。图 [7-1](#Fig1) 说明了使用变分量子本征解算器进行优化的步骤。

![../images/495362_1_En_7_Chapter/495362_1_En_7_Fig1_HTML.jpg](../images/495362_1_En_7_Chapter/495362_1_En_7_Fig1_HTML.jpg)

图 7-1

VQE 的高层流程图

### 定义哈密顿量

在变分量子本征解算器中，我们根据泡利矩阵 *Z* 、 *X* 、 *Y* 和 *I* 来定义哈密顿量。一般来说，任何哈密顿算符或厄米算符都可以用泡利矩阵的张量积来表示。例如，我们可以根据泡利矩阵的张量积来定义两量子位系统的哈密顿量，作为如下的基础:

![$$ H=\sum \limits_{k=0}{c}_k\left({\sigma}_0^{(k)}\otimes {\sigma}_1^{(k)}\right)=\sum \limits_{k=0}{c}_k\prod \limits_{i=0}^{2-1}\otimes {\sigma}_i^{(k)} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ8.png)

(7-9)

在前面的表达式中，![$$ \left({\sigma}_0^{(k)}\otimes {\sigma}_1^{(k)}\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq1.png)或![$$ \prod \limits_{i=0}^{2-1}\otimes {\sigma}_i^{(k)} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq2.png)表示第 *k* 个基，并且每个![$$ {\sigma}_i^{(k)}\in \left\{X,Y,Z,I\right\} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq3.png)项*c*T7】T8】kT10】是对应于每个基的线性系数。![$$ {\sigma}_i^{(k)} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq4.png)中的索引 *i* 表示![$$ {\sigma}_i^{(k)} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq5.png)对应于第 *k* 基中的量子位 *i* 。我们可以把这个表达式推广到一个*n*-量子位系统，并把它的哈密顿量 *H* 写成如下:

![$$ H=\sum \limits_k{c}_k\prod \limits_{i=0}^{n-1}\otimes {\sigma}_i^{(k)}=\sum \limits_k{H}_k $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ9.png)

(7-10)

哈密顿量的泡利基表示有两个优点。

*   It lets us compute the expectation of each Hamiltonian *H*<sub>*k*</sub> with respect to each basis *k* independently and then sum them to get the expectation of the overall Hamiltonian. This is because of the linearity of the expectation shown here:

    ![$$ \left\langle \psi \left|H\right|\psi \right\rangle =\sum \limits_k\left\langle \psi \mid {H}_k|\psi \right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equc.png)

![$$ \to {\left\langle H\right\rangle}_{\psi }=\sum \limits_k{\left\langle {H}_k\right\rangle}_{\psi } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ10.png)

(7-11)

*   The eigenvalues and the eigenvectors for Pauli matrices are known up front, and hence we know for a given Hamiltonian base *H*<sub>*k*</sub> what basis we need to measure the qubits for the expectation computation. For instance, if we are to measure the expectation of a qubit in the state ∣*ψ*⟩ for a given Hamiltonian *H*<sub>*k*</sub> = −*Z*, we can do so by measuring the qubit in the computational basis state |0⟩, ∣1⟩ since we know the eigenvectors of *Z* are ∣0⟩ and ∣1⟩ corresponding to the eigenvalues of 1 and −1\. As the Hamiltonian is given as −*Z*, the eigenvalues change to −1 and +1 corresponding to the eigenvectors ∣0⟩ and ∣1⟩. We can measure the qubit in state ∣*ψ*⟩ in the computational basis as |*ψ*⟩ = *α*|0⟩ + *β* ∣1⟩, and based on the estimates of *α* and *β* from multiple measurements, we can compute the expectation as follows:

    ![$$ {\left\langle -Z\right\rangle}_{\psi }=\lambda \left(|0\Big\rangle \right)\ast P\left(|0\Big\rangle \right)+\kern0.5em \lambda \left(|1\Big\rangle \right)P\left(|1\Big\rangle \right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equd.png)

![$$ \to -{\left|\alpha \right|}^2+{\left|\beta \right|}^2 $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ11.png)

(7-12)

在方程 [7-12](#Equ12) ， *λ* (|0⟩)和 *λ* (|1⟩)是哈密顿量 *Z* 的特征向量∣0⟩和∣1⟩对应的特征值。只是为了检查通过测量量子态计算出的期望值与算符对态∣的期望—*z*ψ⟩匹配基于算符期望公式，我们在这里计算后者:

![$$ {\left\langle -Z\right\rangle}_{\psi }=\left\langle \psi \left|-Z\right|\psi \right\rangle = $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Eque.png)

![$$ \to -\left({\alpha}^{\ast}\right\langle 0\mid +{\beta}^{\ast}\left\langle 1\right|\left)\right(\mid 0\left\rangle \left\langle 0|-|1\right\rangle \right\langle 1\mid \Big)\left(\alpha \left|0\right\rangle +\beta |1\Big\rangle \right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equf.png)

![$$ \to -{\alpha}^{\ast}\alpha +{\beta}^{\ast}\beta =-{\left|\alpha \right|}^2+{\left|\beta \right|}^2 $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ12.png)

(7-13)

因此，我们看到，对于作为哈密顿量的给定泡利矩阵的期望，可以通过以泡利矩阵的特征向量作为测量的基础来测量状态来计算。对任何哈密顿量来说都是如此。然而，当我们处理泡利矩阵时，我们预先知道特征值和特征向量，因此通过测量已知特征基中的状态向量，我们可以计算期望值。此外，这个过程可以推广到哈密顿基，哈密顿基是对应于多个量子位的泡利矩阵的张量积。在接下来的期望计算部分中，我们将针对具有由 *Z* ⊗ *X* 给出的哈密顿量的两量子位系统来说明这一点，其中 *Z* 代表第一量子位的哈密顿量，而 *X* 代表第二量子位的哈密顿量。

### 基于期望优化准备 Ansatz 状态

一旦我们定义了一个期望最小的哈密顿量，我们的目标就是确定对应于最小特征值的特征向量。基于哈密顿量，我们定义了一个具有所需数量的量子位 *n* 的量子系统，其初始状态为∣*ψ*T4】0⟩.∣*ψ*t8】0⟩状态由以 *θ* 参数化的酉变换 *U* ( *θ* 控制，可以根据需要将初始状态∣*ψ*<sub>*o*</sub>⟩变为| *ψ* ( *θ* )⟩。在变分法领域中，可以基于经典计算模块的优化参数 *θ* 来准备的这种状态| *ψ* ( *θ* )⟩被称为 *ansatz* 。在 VQE 的每次迭代 *k* 中，我们通过测量哈密顿本征基中的状态∣*ψ*(*θ*<sub>*k*</sub>)⟩来计算哈密顿量 *H* 的期望，并计算期望。期望值被输入到经典优化器，如 nel der–Mead 或 COYBLA。经典优化器得出的优化值为*θ*<sub>*k*+1</sub>，这是为了提高对新状态的期望值，如下所示:

![$$ \left|\psi \left({\theta}_{k+1}\right)\right\rangle =U\left({\theta}_{k+1}\mid {\psi}_o\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ13.png)

(7-14)

总之，我们使用量子计算来演化状态，并在适当的基础上通过测量来计算期望值，并通过给出适当的参数 *θ* <sub>*k*</sub> ，使用经典计算来优化哈密顿成本函数。经典优化器在迭代 *k* 中给出的参数*θ*<sub>*k*</sub>对应于在某个初始状态上通过酉变换*u*(*θ*<sub>*k*</sub>)得到的优化状态∣*ψ*(*θ*<sub>*k*</sub>)⟩。

## 期望值计算

我们讨论了哈密顿量 *H* 的期望⟨ *H* ⟩计算是通过将哈密顿量分解为由泡利矩阵的张量积形成的基的线性和来完成的，其中泡利矩阵代表对应于单个量子位的哈密顿量基。为了用一个例子来说明这一点，让我们把两个量子位系统的哈密顿基作为 *Z* ⊗ *X* 其中 *Z* 代表量子位*q*T12】1 的哈密顿基，而 *X* 代表量子位*q*t18】2 的哈密顿基。 *Z* ⊗ *X* 的哈密顿量可以矩阵形式写成如下:

![$$ Z\otimes X=\left[\begin{array}{cc}1&amp; 1\\ {}1&amp; -1\end{array}\right]\otimes \left[\begin{array}{cc}0&amp; 1\\ {}1&amp; 0\end{array}\right]=\left[\begin{array}{cccc}0&amp; 1&amp; 0&amp; 1\\ {}1&amp; 0&amp; 1&amp; 0\\ {}0&amp; 1&amp; 0&amp; -1\\ {}1&amp; 0&amp; -1&amp; 0\end{array}\right] $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ14.png)

(7-15)

就拿通常计算基础中可以写成![$$ \frac{1}{2}{\left[1\ 1\ 1\ 1\right]}^T $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq7.png)的状态![$$ \left|\psi \right\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right)\otimes \frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right)=\frac{1}{2}\ \left(\left|00\right\rangle +\left|01\right\rangle +\left|10\right\rangle +|11\Big\rangle \right), $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq6.png)来说吧。基于测量的 POVM 公设，相对于状态∣ * ψ * ⟩的 *Z* ⊗ *X* 的期望值由下式给出:

![$$ \left\langle Z\otimes X\right\rangle =\frac{1}{4}\ \left[1\ 1\ 1\ 1\right]\left[\begin{array}{cccc}0&amp; 1&amp; 0&amp; 1\\ {}1&amp; 0&amp; 1&amp; 0\\ {}0&amp; 1&amp; 0&amp; -1\\ {}1&amp; 0&amp; -1&amp; 0\end{array}\right]\ \left[\begin{array}{c}1\\ {}1\\ {}1\\ {}1\end{array}\right]=1 $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ15.png)

(7-16)

现在让我们通过测量对应于 *Z* ⊗ *X* 中泡利矩阵的本征基中的量子位状态来计算期望值。对于量子位*q*T6】1，哈密顿矩阵是 *Z* ，因此特征值是 1 和 1，对应于特征向量∣0⟩和∣1⟩.在状态![$$ \left|\psi \right\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right)\otimes \frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq8.png)中表示的量子位 *q* <sub>1</sub> 是属于 *Z* 的特征向量的通常的∣0⟩和∣1⟩基。量子位 *q* <sub>2</sub> 的状态需要在|+⟩和∣−⟩基中表示，其中![$$ \left|+\right\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq9.png)和![$$ \left|-\right\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle -|1\Big\rangle \right). $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq10.png)这是因为对应于算符 *q* <sub>2</sub> 的哈密顿量是 *X* ，其特征向量是对应于特征值 1 和 1 的|+⟩和∣−⟩态。因此，以它们各自的哈密顿量为基础表示的两个量子位的组合状态可以表示如下:

![$$ \left|\psi \right\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right)\otimes \frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equg.png)

![$$ =\frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right)\kern0.75em \otimes \mid +\Big\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ16.png)

(7-17)

现在假设我们在∣0⟩和∣1⟩的基础上测量量子位*q*T2】1，在∣+⟩和∣−⟩的基础上测量量子位*q*T6】2。测量时方程 [7-17](#Equ16) 中表示的状态将产生两个本征态![$$ \frac{1}{\sqrt{2}}\left|0\right\rangle \otimes \mid +\Big\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq11.png)和![$$ \frac{1}{\surd 2}\left|1\right\rangle \otimes \mid +\Big\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq12.png)中的任一个，其概率幅度为![$$ \frac{1}{\sqrt{2}} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq13.png)。对应于状态|0⟩ ⊗ |+⟩的特征值是对应于哈密顿量 *Z* 的∣0⟩特征向量和哈密顿量 *X* 的∣+⟩特征向量的单个特征值的乘积。这两个特征值都是 1，因此对应于|0⟩ ⊗ ∣+⟩的特征值是 1。同样，状态|1⟩ ⊗ ∣+⟩的特征值为 1×1 = 1。于是，哈密顿量的总体期望如下:

![$$ {\left\langle Z\otimes X\right\rangle}_{\psi }=\lambda \left(|0\Big\rangle \otimes |+\Big\rangle \right)\ast P\left(|0\Big\rangle \otimes |+\Big\rangle \right)+\kern0.75em \lambda \left(\left|1\right\rangle \otimes |+\Big\rangle \right)P\left(\left|1\right\rangle \otimes |+\Big\rangle \right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equh.png)

![$$ ={\left(\frac{1}{\sqrt{2}}\right)}^2+{\left(\frac{1}{\sqrt{2}}\right)}^2=1 $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ17.png)

(7-18)

因此，我们看到，通过测量与泡利算符所表示的哈密顿量相对应的本征基中的量子位所计算的期望，等价于基于算符期望公式相对于状态∣ *ψ* ⟩所计算的 *Z* ⊗ *X* 的期望。

## Isling 模型及其哈密顿量

Isling 模型可以看作是一个抽象的数学框架，由排列在一个网格中的几个元素组成。Isling 模型的元素可以以+1 或-1 这两种状态存在，每个元素都以不同的程度与相邻元素相互作用。元素状态之间的相互作用仅限于双向相互作用。给定一个由 *n* × *n* 个元素组成的正方形点阵，Isling 模型中的元素可以表示为如图 [7-2](#Fig2) 所示。如果我们考虑元素*q*T8】10，它只与网格中最近的邻居交互；即 *q* <sub>6</sub> ， *q* <sub>9</sub> ， *q* <sub>14，</sub>和 *q* <sub>11</sub> 。

![../images/495362_1_En_7_Chapter/495362_1_En_7_Fig2_HTML.jpg](../images/495362_1_En_7_Chapter/495362_1_En_7_Fig2_HTML.jpg)

图 7-2

伊辛模型

元素 *q* <sub>*i*</sub> 中的每一个都可以被视为可以占据+1 和-1 两种状态的随机变量。如果我们用随机变量 *σ* <sub>*i*</sub> 来表示元素*q*<sub>**I**</sub>的状态，那么每一个*σ*<sub>*I*</sub>∈{-1，1}。让我们试着想出一个哈密顿量，它包含了所有可能的元素状态的系统能量。在 Isling 模型中，处于相同状态的两个相邻元素被认为是比元素状态矛盾时更稳定的配置。在这方面，两个元素 *q* <sub>*i*</sub> 和 *q* <sub>*j*</sub> 的哈密顿分量可以表示如下:

![$$ {e}_{ij}=-{c}_{ij}{\sigma}_i{\sigma}_j $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ18.png)

(7-19)

在方程 [7-19](#Equ18) 中，*c*<sub>T5】ij</sub>≥0 表示两个元素 *q* <sub>*i*</sub> 和 *q* <sub>*j*</sub> 相互作用的强度。可以看出，当 *σ* <sub>*i*</sub> 和 *σ* <sub>*j*</sub> 符号相同时，即*σ*<sub>*I*</sub>*σ*<sub>*j*</sub>*c*对于不同状态的相邻元素，这个相互作用能是*c*<sub>*ij*</sub>。因此，方程 [7-19](#Equ19) 清楚地模拟了一个相互作用能，当状态一致时比状态不一致时在数量上更低。

![$$ {E}_1=-\sum \limits_{\left\langle ij\right\rangle }{c}_{ij}{\sigma}_i{\sigma}_j $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ19.png)

(7-20)

总的相互作用能量可以由等式 [7-20](#Equ19) 表示，其中⟨ *i* ， *j* ⟩是最近邻元素对的总和。能量的另一个组成部分来自元素的单个状态，可以表示如下:

![$$ {E}_2=-\sum \limits_i{b}_i{\sigma}_i $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ20.png)

(7-21)

Isling 模型中系统的总能量由相互作用能量 *E* <sub>1</sub> 和个体能量 *E* <sub>2</sub> 之和给出，如下所示:

![$$ E=-\sum \limits_{\left\langle ij\right\rangle }{c}_{ij}{\sigma}_i{\sigma}_j-\sum \limits_i{b}_i{\sigma}_i $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ21.png)

(7-22)

事实上，Isling 模型是由 Wilhelm Lenz 开发的，用于模拟铁磁性。在存在沿方向 *z* 工作的强度 *B* 的磁场时，认为 *n* 元素是 *n* 原子。还假设每个原子 *q* <sub>*i*</sub> 表示自旋系统，其中状态*σ*<sub>*I*</sub>=+1 表示自旋向上，而*σ*<sub>*I*</sub>= 1 表示自旋向下系统。 *n* 原子系统的总能量包含了类似于*e*<sub>*ij*</sub>的相邻原子之间的相互作用能量，以及每个原子上的磁场 *B* 产生的能量。我们可以把系统的整体能量记下来如下:

![$$ E=-C\sum \limits_{\left\langle ij\right\rangle }{\sigma}_i{\sigma}_j-\mu B\sum \limits_i{\sigma}_i $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ22.png)

(7-23)

在方程 [7-23](#Equ22) 中， *C* 称为*交换能量*，而 *μ* 称为*磁矩*。由于每个原子可以以两种状态存在，所以 *n* 个原子的配置总数是 2<sup>nT15】。等式 [7-23](#Equ23) 中的第一项表明，当原子的自旋状态彼此一致时，相互作用能量将最小化。能量的总体最小化将取决于磁场 *B* 的方向。当 *B* 为负时，所有原子都处于自旋向下状态时能量最小，即*σ*T24】T25】IT27】= 1，而当 *B* 为正时，所有原子的*σ*T32】T33】IT35】= 1 时能量最小。虽然是针对铁磁性开发的，但之前讨论的 Isling 模型像数学框架一样适用于更广泛的物理现象和抽象问题，因此我们将使用方程 [7-22](#Equ21) 中的通用公式来模拟使用 Isling 模型的系统能量。</sup>

由于方程 [7-22](#Equ21) 中的能量函数给出了一个抽象系统在其每一种构型下的能量，因此可以将其视为该系统的哈密顿量。

## 量子系统的 Isling 模型

我们可以将 Isling 模型扩展到一个由 *n* 个量子位组成的系统，其中自旋向下和自旋向上可以由对应于能量标签 1 和+1 的量子位状态∣0⟩和∣1⟩来表示。量子位的 1 和+1 能级可以作为对应于本征态∣0⟩和∣1⟩.的哈密顿量的本征值这样一个哈密顿量可以写成如下的谱形式:

![$$ {H}_q=-1\left|0\right\rangle \left\langle 0\left|+1\right|1\right\rangle \left\langle 1\right| $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equi.png)

![$$ =-\left(\ |0\right\rangle \left\langle 0\left|-\right|1\right\rangle \left\langle 1|\right)=-\left[\begin{array}{cc}1&amp; 0\\ {}0&amp; -1\end{array}\right]=-Z $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ23.png)

(7-24)

我们可以从等式 [7-24](#Equ23) 中看到，与量子位的各个状态相关的能量可以用泡利 *Z* 矩阵来表示。这是一个重要的关系，因为它直接关系到量子位的各个状态的能量。因此，对于 *n* 个量子比特的系统，哈密顿量的能量*E*T6】2 可以表示如下:

![$$ {E}_2=-\sum \limits_i{b}_i{Z}_i $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ24.png)

(7-25)

在方程 [7-25](#Equ24) ，*Z*<sub>T5】I</sub>是量子位 *i* ∈ {1，2，.. *n* }，和 *b* <sub>*i*</sub> 是属于每个量子位的系数。为了得到每一个泡利矩阵 *Z* <sub>*i*</sub> 的严格矩阵记法，我们应该将另一个*n*1 个量子位对应的哈密顿量设为恒等式 *I* <sub>2 × 2</sub> 。例如，对于一个三量子位系统，*z*t34】2 应该写成*I*t38】1⊗*z*t42】2⊗*I*t46】3。然而，在等式 [7-25](#Equ25) 中，我们选择将*I*<sub>1</sub>⊗*z*<sub>2</sub>⊗*I*<sub>3</sub>写成 *Z* <sub>2</sub> 以避免混淆符号，并且将遵循相同的符号。

现在让我们看看如何用合适的哈密顿量来表示相邻量子位之间的相互作用。根据 Isling 模型，两个相邻的量子位 *q* <sub>*i*</sub> 和 *q* <sub>*j*</sub> 当它们的状态彼此一致时应该比当它们的状态不同时具有更低的能量。如果两个量子位之间的相互作用能量系数由*c*<sub>*ij*</sub>给出，那么对于两个量子位的不同构型，相互作用能量应该如表 [7-1](#Tab1) 所示。

表 7-1

双向量子位相互作用的状态-能量映射

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

组合能量状态为***q***<sub>***I***</sub>和***q***<sub>***j***</sub>

 | 

活力

 |
| --- | --- |
| ∣00⟩ | -*c*<sub>T3】ijT5】</sub> |
| ∣ **01** ⟩ | *c*<sub>T3】ijT5】</sub> |
| ∣ **10** ⟩ | *c*<sub>T3】ijT5】</sub> |
| ∣ **11** ⟩ | -*c*<sub>T3】ijT5】</sub> |

把能级看作本征值，把能态看作相应的本征向量，我们可以把相互作用的哈密顿量写成如下:

![$$ {H}_{qq}=-{c}_{ij}\left|00\right\rangle \left\langle 00\right|+{c}_{ij}\left|01\right\rangle \left\langle 01\right|+{c}_{ij}\left|10\right\rangle \left\langle 10\right|+{c}_{ij}\left|11\right\rangle \left\langle 11\right| $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equj.png)

![$$ =\left[\begin{array}{cccc}-{c}_{ij}&amp; 0&amp; 0&amp; 0\\ {}0&amp; {c}_{ij}&amp; 0&amp; 0\\ {}0&amp; 0&amp; {c}_{ij}&amp; 0\\ {}0&amp; 0&amp; 0&amp; -{c}_{ij}\end{array}\right]=-{c}_{ij}\left[\begin{array}{cccc}1&amp; 0&amp; 0&amp; 0\\ {}0&amp; -1&amp; 0&amp; 0\\ {}0&amp; 0&amp; -1&amp; 0\\ {}0&amp; 0&amp; 0&amp; 1\end{array}\right] $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ25.png)

(7-26)

从方程 [7-26](#Equ25) 可以看出，哈密顿量是一个对角矩阵，对角线依次代表∣00⟩、∣10⟩、∣10⟩和∣11⟩.态的相互作用能我们可以用泡利 *Z* 矩阵的张量积来表示对角矩阵，如下所示:

![$$ {H}_{qq}=-{c}_{ij}\left[\begin{array}{cccc}1&amp; 0&amp; 0&amp; 0\\ {}0&amp; -1&amp; 0&amp; 0\\ {}0&amp; 0&amp; -1&amp; 0\\ {}0&amp; 0&amp; 0&amp; 1\end{array}\right] $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equk.png)

![$$ =-{c}_{ij}\left[\begin{array}{cc}1&amp; 0\\ {}0&amp; -1\end{array}\right]\otimes \left[\begin{array}{cc}1&amp; 0\\ {}0&amp; -1\end{array}\right] $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equl.png)

![$$ =-{c}_{ij}{Z}_i\otimes {Z}_j $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ26.png)

(7-27)

所以，考虑所有邻居的相互作用哈密顿量可以表示如下:

![$$ {E}_1=-\sum \limits_{\left\langle i,j\right\rangle }{c}_{ij}{Z}_i\otimes {Z}_j $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ27.png)

(7-28)

结合方程 [7-25](#Equ24) 和方程 [7-28](#Equ27) ，我们可以写出 *n* 量子位系统的整体 Isling 哈密顿量如下:

![$$ E={E}_1+{E}_2=-\sum \limits_{\left\langle i,j\right\rangle }{c}_{ij}{Z}_i\otimes {Z}_j-\sum \limits_i{b}_i{Z}_i $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ28.png)

(7-29)

因此，我们可以从方程 [7-29](#Equ28) 中看到，我们可以完全用泡利矩阵 *Z* 来表示一个 *n* 量子位系统的 Isling 哈密顿量。这在诸如 VQE 和 QAOA 的算法中是有利的，因为我们可以仅通过相对于通常的∣0⟩和∣1⟩基进行测量来计算哈密顿量的期望。此外，Isling 模型可以推广到任何给定的一组输入量子位或元素，它们不一定必须位于网格或晶格上。两个量子位或元素是否相邻，可以基于物理系统或问题公式化，单独由相互作用系数*c*T8】T9】ijT11】来控制。例如，如果 Isling 系统的元素是图中的节点，邻接矩阵中定义的节点之间的边权重可以起到交互系数*c*T14】T15】ijT17】的作用。对于给定的节点 *i* ，可以通过查看所有节点 *j* 来确定其邻居，其中*c*<sub>*ij*</sub>≠0。

## VQE 算法的实现

在这一节中，我们实现了一个 Isling 哈密顿量的 VQE 算法。清单 [7-1](#PC1) 显示了详细的实现以及对每个重要功能的适当解释。

```py
import cirq
import numpy as np
from scipy.optimize import minimize

Listing 7-1VQE Implementation for Isling Hamiltonian

```

接下来，我们定义一个`setup_vqe`函数，它接受我们计划最小化其期望值的哈密顿量的基。标记为`hamiltonian_bases`的哈密顿基是泡利矩阵的张量积。例如，为了表示作为泡利矩阵 *Z* 的张量积的两量子位哈密顿量，我们将`hamiltonian_bases`设置为 *ZZ* 。`setup_vqe`还通过`setup_vqe`中的`hamiltonian_scales`获取每个哈密顿量的比例因子。基于输入到`setup_vqe`中的哈密顿量的定义，它计算单个基本哈密顿量的特征值，用于以后的期望值计算。

```py
def setup_vqe(hamiltonian_bases=['ZZZ'],
         hamiltonian_scales=[-1.0]):

    num_qubits = len(hamiltonian_bases[0])
    eigen_values_dict = {}

    for base,scale in zip(hamiltonian_bases,hamiltonian_scales):
        eigen_values = []
        for i, char in enumerate(base):
            if char == 'Z':
                eigens = np.array([1, -1])
            elif char == 'I':
                eigens = np.array([1, 1])
            else:
                raise NotImplementedError(f"The Gate {char}
                  is yet to be implemented")

            if len(eigen_values) == 0:
                eigen_values = eigens
            else:
                eigen_values = np.outer(eigen_values
                                ,eigens).flatten()

        eigen_values_dict_elem = {}

        for i, x in enumerate(list(eigen_values)):
            eigen_values_dict_elem[i] = scale * x

        eigen_values_dict[base] = eigen_values_dict_elem

    return eigen_values_dict, num_qubits

```

我们定义了一个名为`ansatz_parameterized`的 ansatz，它接受参数`theta`，并基于`theta`中的参数执行量子位围绕 *y* 轴的旋转。

```py
def ansatz_parameterized(theta,num_qubits=3):
    """
    Create an Ansatz
    :param theta:
    :param num_qubits:
    :return:
    """
    qubits = [cirq.LineQubit(c) for c in range(num_qubits)]
    circuit = cirq.Circuit()
    for i in range(num_qubits):
        circuit.append(cirq.Ry(theta[i]*np.pi)(qubits[i]))
    circuit.append(cirq.measure(*qubits, key="m"))
    return circuit, qubits

```

这是期望计算程序`compute_expectation`,基于与每个量子位相关的泡利哈密顿基有关的相关基中的量子位的测量。该测量给出了哈密顿量的每个本征态的概率，并且这被用于计算哈密顿量的本征值的期望。

```py
def compute_expectation(circuit, eigen_value_dict={}, copies=10000) -> float:
    sim = cirq.Simulator()
    results = sim.run(circuit, repetitions=copies)
    output = dict(results.histogram(key='m'))
    print('Stats', output)
    _expectation_ = 0
    for base in list(eigen_value_dict.keys()):
        for i in list(output.keys()):
            _expectation_ += eigen_value_dict[base][i]*
             output[i]

    _expectation_ = _expectation_ / copies

    return _expectation_

```

我们将迄今为止在`VQE_routine`中定义的函数放在一起，以执行给定哈密顿量的预期最小化。`VQE_routine`使用经典优化器优化 ansatz 的`theta`参数，使量子位收敛到哈密顿量的最低本征值状态。我们使用`scipy.optimize`包中的`COBYLA`方法来执行优化。本质上，优化器接受通过与由`theta`定义的给定状态相关的测量计算的哈密尔顿函数的期望值，并返回优化的`theta`。这个迭代过程一直进行到`theta`产生哈密顿量的最低本征值状态。

```py
def VQE_routine(hamiltonian_bases=['ZZZ']
                ,hamiltonian_scales=[1.],
                 copies=1000, vqe_iterations=100,
                 initial_theta=[0.5, 0.5, 0.5], verbose=True):
    eigen_value_dict,num_qubits=
          setup_vqe(hamiltonian_bases=hamiltonian_bases
                    ,hamiltonian_scales=hamiltonian_scales)
    print(eigen_value_dict)
    initial_theta = np.array(initial_theta)

    def objective(theta):
        circuit, qubits = ansatz_parameterized(theta, num_qubits)
        expectation = compute_expectation(circuit
                    ,eigen_value_dict, copies)
        if verbose:
            print(f" Theta: {theta} Expectation:
            {expectation}")

        return expectation

    result = minimize(objective, x0=initial_theta
                      , method="COBYLA")
    print(result)
    return result.x,result.fun

```

**测试哈密顿量:*****—z⊗z***

首先，我们将尝试优化由 *Z* ⊗ *Z* 给出的两量子位系统哈密顿量。它有两个基态，∣00⟩和∣11⟩，属于特征值 1。所以，它应该收敛到两个本征态中的任何一个。

```py
if __name__ == '__main__':
    optim_theta, optim_func,hist_stats
               = VQE_routine(hamiltonian_bases=['ZZ'],
                 hamiltonian_scales=[-1.0],
                 initial_theta=[0.75,0.75])
    print(f"VQE Results: Minimum Hamiltonian
          Energy:{optim_func} at theta: {optim_theta}")
    print(f"Histogram for optimized State:", hist_stats)

```

**输出**

```py
VQE Results: Minimum Hamiltonian Energy:-1.0 at theta: [2.01361981 1.99155862]

Histogram for optimized State: {0: 999, 2: 1}

```

我们可以从输出中看到，表示哈密顿量最低能量的所需特征值 1——z⊗*z*已经以几乎为 1 的概率在所需本征态∣00⟩之一处实现。

**测试哈密顿量:*****—z⊗z⊗I***

我们现在将使用哈密顿量*z*⊗*z**z*⊗*I*来尝试 VQE。哈密顿量的最低本征值是 2，属于本征态∣00⟩.

```py
if __name__ == '__main__':
    optim_theta, optim_func,hist_stats
            = VQE_routine(hamiltonian_bases=['ZZ','ZI'],
              hamiltonian_scales=[-1.0,-1.0],
                 initial_theta=[0.5, 0.5])
    print(f"VQE Results: Minimum Hamiltonian
        Energy:{optim_func} at theta: {optim_theta}")
    print(f"Histogram for optimized State:", hist_stats)

```

**输出**

```py
VQE Results: Minimum Hamiltonian Energy:-1.998 at theta: [1.99400595 0.03030307]
Histogram for optimized State: {0: 1000}

```

从输出中可以看出，优化收敛到所需的最低特征值 2，对应于概率为 1 的∣00⟩状态。

## 量子最大割图聚类

最大割法是一种图划分技术，将图 *G* = ( *V* ， *E* )划分为两个分区 *S* <sub>1</sub> 和 *S* <sub>2</sub> ，使得两个分区之间的边数最大化。对于加权图，最大割试图最大化两个分区之间的边的权重之和，而不是边的数量。图 [7-3](#Fig3) 是一个图上的最大割划分图，其中顶点 A 和 B 属于同一个划分*S*T18】1 而 C、D 和 E 属于划分*S*T22】2。

![../images/495362_1_En_7_Chapter/495362_1_En_7_Fig3_HTML.jpg](../images/495362_1_En_7_Chapter/495362_1_En_7_Fig3_HTML.jpg)

图 7-3

最大切割

我们可以看到，最大割使两个分区之间的边数最大化。最大割通常用于将图聚类成两个簇，其中边表示连接它们的两个顶点之间的某种形式的不同。通过最大化两组顶点之间的边数或边权重之和，我们最大化了两个聚类之间的相异度。或者，我们最小化两个集群中两组顶点之间的相似性。在这点上，如果我们考虑边权重来表示相似性而不是距离，我们需要最小化两个聚类的顶点之间的边权重之和。这样的公式被称为*最小割聚类*。基于我们是否使用边来表示距离或相似性，我们可以相应地使用最大割或最小割来聚类顶点。

我们考虑一个图 *G* 具有 *n* 个顶点*v*T6】1，*v*T10】2，…， *v* <sub>*n*</sub> ，其聚类分配由 *z* <sub>1</sub> ， *z* <sub>2，</sub> …，*z*给出因此， *z* <sub>*i*</sub> 中的每一个可以属于两个集群，我们将其标记为 1 和 1。**

如果边权重 *w* <sub>*ij*</sub> 表示两个顶点 *i* 和 *j* 之间的距离，则最大割方法的目标可以写成:

![$$ C\left({z}_1,{z}_2\dots {z}_n\right)=\frac{1}{2}\sum \limits_i\sum \limits_{j&gt;i}{w}_{ij}{z}_i\left(1-{z}_j\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ29.png)

(7-30)

作为最大割优化的一部分，我们感兴趣的是找到最佳的集群分配![$$ {z}^{\ast }={\left[{z}_1^{\ast },{z}_2^{\ast}\dots {z}_n^{\ast}\right]}^T $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq14.png)。

![$$ {z}^{\ast }=\underset{z}{\underbrace{argmax}}\frac{1}{2}\sum \limits_i\sum \limits_{j&gt;i}{w}_{ij}{z}_i\left(1-{z}_j\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ30.png)

(7-31)

让我们取对应于任意两个顶点 *i* 和 *j* 之间的相互作用的目标![$$ {C}_{ij}=\frac{1}{2}{w}_{ij}{z}_i\left(1-{z}_j\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq15.png)，并验证这与最大割的目标一致。

**案例一:***w*<sub>T5】ij</sub>= 1 和*z*<sub>*I*</sub>=*z*<sub>*j*</sub>。

在这种情况下，顶点 *i* 和顶点 *j* 的分配应该在不同的群中，因为它们具有最大的距离。然而，由于*z*<sub>*I*</sub>=*z*<sub>*j*</sub>我们对于目标具有次优值 0。目标本来有最优值*w*<sub>*ij*</sub>= 1 有 *z* <sub>*i*</sub> 和 *z* <sub>*j*</sub> 属于不同的聚类。

**案例二:***w*<sub>T5】ij</sub>= 1 和*z*<sub>*I*</sub>≦*z*<sub>*j*</sub>，说*z*<sub>*I*</sub>= 1 和*z*<sub>*j【T39】*</sub>

在这种情况下，将顶点 *i* 和 *j* 分配到不同的簇中给我们提供了最优的目标分数![$$ \frac{1}{2}{w}_{ij}1\left(1-\left(-1\right)\right)={w}_{ij} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq16.png)。

**案例三:***w*<sub>T5】ij</sub>= 0

在这种情况下，目标 *C* <sub>*ij*</sub> = 0，而不管顶点 *i* 和 *j* 是否属于同一簇。

现在让我们把经典的目标函数推广到一个由量子系统的哈密顿量表示的目标函数。我们可以用一个量子位来表示图 *G* 的每个顶点，其中量子位的状态决定了它被分配到哪个簇。对应于顶点 *i* 和 *j* 的每对量子位的目标可以由泡利 *Z* 矩阵的张量积给出的成本哈密顿量来表示，如下所示:

![$$ {H}_{ij}={w}_{ij}\left(I-{Z}_i\otimes {Z}_j\right)={w}_{ij}I-{w}_{ij}\left[\begin{array}{cc}1&amp; 0\\ {}0&amp; -1\end{array}\right]\otimes \left[\begin{array}{cc}1&amp; 0\\ {}0&amp; -1\end{array}\right] $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equm.png)

![$$ ={w}_{ij}\left[\begin{array}{cccc}0&amp; 0&amp; 0&amp; 0\\ {}0&amp; 1&amp; 0&amp; 0\\ {}0&amp; 0&amp; 1&amp; 0\\ {}0&amp; 0&amp; 0&amp; 0\end{array}\right] $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ31.png)

(7-32)

当量子位的状态不一致时，即对于本征态∣01⟩和∣10⟩.，代表不同本征态下的哈密顿量成本的本征值在类似地，当量子位的状态一致时，哈密顿成本为 0。这与我们在 max-cut 的经典公式中所看到的是一致的。在这些行上，我们可以将最大割问题的总体哈密顿量写成如下:

![$$ H=\sum \limits_{&lt;i,j&gt;}{w}_{ij}\left(I-{Z}_i\otimes {Z}_j\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ32.png)

(7-33)

在最大割问题中，我们希望找到量子位|*ϕ*⟩=∣*z*T4】1T6】z<sub>2</sub>……*z*<sub>*n*</sub>⟩的组合状态，使哈密顿量 *H* 的期望值最大化。

*H* 的期望值由下面给出:

![$$ \left\langle H\right\rangle =\left\langle \phi \left|H\right|\phi \right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equn.png)

![$$ =\sum \limits_{&lt;i,j&gt;}{w}_{ij}\left\langle \phi \left|I-{Z}_i\otimes {Z}_j\right|\phi \right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equo.png)

![$$ =\sum \limits_{\left\langle i,j\right\rangle }{w}_{ij}\left\langle \phi \left|\phi \right\rangle -\sum \limits_{\left\langle i,j\right\rangle }{w}_{ij}\right\langle \phi \left|{Z}_i\otimes {Z}_j|\phi \right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equp.png)

![$$ =\sum \limits_{\left\langle i,j\right\rangle }{w}_{ij}-\left\langle \sum \limits_{\left\langle i,j\right\rangle }{w}_{ij}{Z}_i\otimes {Z}_j\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ33.png)

(7-34)

现在对于给定的图 *G* ，方程 [7-34](#Equ33) 中的第一项是常数，因此我们可以丢弃它，只最大化第二项![$$ -\left\langle \sum \limits_{\left\langle i,j\right\rangle }{w}_{ij}{Z}_i\otimes {Z}_j\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq17.png)。同样，我们可以选择最小化它的负值，即![$$ \left\langle \sum \limits_{\left\langle i,j\right\rangle }{w}_{ij}{Z}_i\otimes {Z}_j\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq19.png)，而不是最大化![$$ -\left\langle \sum \limits_{\left\langle i,j\right\rangle }{w}_{ij}{Z}_i\otimes {Z}_j\right\rangle, $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq18.png)的期望值，因为经典优化器更倾向于最小化目标而不是最大化目标。这使得最终的哈密顿量 *H* <sub>* c *</sub> 其期望被最小化以获得最大割解如下:

![$$ {H}_c=\sum \limits_{&lt;i,j&gt;}{w}_{ij}{Z}_i\otimes {Z}_j $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ34.png)

(7-35)

既然我们已经找出了期望被最小化的哈密顿量 *H* <sub>*c*</sub> ，我们可以通过将哈密顿量 *H* <sub>*c*</sub> 输入到已经实现的 VQE 例程中来实现。

## 使用 VQE 实现最大割聚类

在这一节中，我们将使用我们在本章前面实现的 VQE 例程来实现具有四个顶点的图的最大割算法。该例程的重点是根据泡利矩阵 *Z* 的张量积适当地定义哈密顿量，作为哈密顿量*H*<sub>T5】c</sub>的基础。每个基础的权重基于所提供的图邻接矩阵。

图邻接矩阵给出了相似性的度量。我们将图的邻接相似矩阵转化为距离矩阵，以此来解决最大割问题。对于距离不为零的两个顶点 *w* <sub>*ij*</sub> ，我们定义顶点 *i* 和 *j* 相互作用对应的哈密顿量为*w*<sub>*ij*</sub>*z*<sub>*I*</sub>⊗*z*<sub>*j**z*<sub>*I*</sub>⊗*z*<sub>*j*</sub>是哈密顿基，而*w*<sub>*ij*</sub>是`vqe_simulation`例程对应的哈密顿系数。我们为每一对具有非零距离的顶点建立这样一个哈密尔顿基。</sub>

清单 [7-2](#PC10) 展示了最大割聚类问题的详细实现。

```py
import cirq
from vqe_cirq import *
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

class QuantumMaxCutClustering:

    def __init__(self, adjacency_matrix:np.ndarray,
                 invert_adjacency=True):
        self.adjacency_matrix = adjacency_matrix
        self.num_vertices = self.adjacency_matrix.shape[0]
        self.hamiltonian_basis_template = 'I' * self.num_vertices
        if invert_adjacency:
            self.hamiltonian = 1 - self.adjacency_matrix
        else:
            self.hamiltonian = self.adjacency_matrix

Listing 7-2Max-Cut Clustering

```

在`create_max_cut_hamiltonian`中，对于每一对非零距离为 *w* <sub>*ij*</sub> 的顶点，我们用哈密顿系数*w*<sub>*ij*</sub>创建哈密顿基*z*<sub>*I*</sub>⊗*z*<sub>*j*</sub>。哈密尔顿基和它们相应的权重系数，称为`hamiltonian_bases`和`hamiltonian_coefficients`，从我们在本章的早期实现中输入到`vqe_routine`进行优化。

```py
    def create_max_cut_hamiltonian(self):

        hamiltonian_bases, hamiltonian_coefficients = [], []
        for i in range(self.num_vertices):
            for j in range(i + 1, self.num_vertices):
                if self.hamiltonian[i, j] > 0:
                    hamiltonian_coefficients.append(
                      self.hamiltonian[i, j])

                    hamiltonian_base = ''
                    for k, c in enumerate
                     (self.hamiltonian_basis_template):
                        if k in [i, j]:
                            hamiltonian_base += 'Z'
                        else:
                            hamiltonian_base += self.hamiltonian_basis_template[k]
                    hamiltonian_bases.append(hamiltonian_base)
        return hamiltonian_bases, hamiltonian_coefficients

    def vqe_simulation(self, hamiltonian_bases,
                       hamiltonian_coefficients,
                       initial_theta=None,
                       copies=10000):
        if initial_theta is None:
            initial_theta = [0.5] * self.num_vertices
        optim_theta, optim_func, hist_stats = \
            VQE_routine(hamiltonian_bases=hamiltonian_bases,
                        hamiltonian_scales=
                    hamiltonian_coefficients,
                        initial_theta=initial_theta,
                        copies=copies)
        solution_stat = max(hist_stats, key=hist_stats.get)
        solution_stat = bin(solution_stat).replace("0b", "")
        solution_stat = (self.num_vertices - len(solution_stat)) * "0" + solution_stat

        return optim_theta, optim_func, hist_stats, solution_stat

```

从`vqe_simulation`中的`vqe_routine execution`导出的优化状态给出顶点的簇标签。具有量子位状态∣0⟩的顶点属于一个群集，而具有量子位状态∣1⟩的顶点属于另一个群集。我们通过基于聚类标签给顶点着色来注释基于距离的图。

```py
    def max_cut_cluster(self, distance_matrix, solution_state):
        print(distance_matrix)
        G = nx.Graph()
        G.add_nodes_from(np.arange(0, self.num_vertices, 1))
        edge_list = []
        for i in range(self.num_vertices):
            for j in range(i + 1, self.num_vertices):
                if distance_matrix[i, j] > 0:
                    edge_list.append((i, j, 1.0))
        G.add_weighted_edges_from(edge_list)
        colors = []
        for s in solution_state:
            if int(s) == 1:
                colors.append('r')
            else:
                colors.append('b')
        pos = nx.spring_layout(G)
        default_axes = plt.axes(frameon=True)
        nx.draw_networkx(G, node_color=colors, node_size=600, alpha=.8, ax=default_axes, pos=pos)
        plt.show()

    def main(self):
        hamiltonian_bases, hamiltonian_coefficients
              = self.create_max_cut_hamiltonian()
        print("Hamiltonian bases:", hamiltonian_bases)
        optim_theta, optim_func, \
        hist_stats, solution_state
            = self.vqe_simulation(hamiltonian_bases,
                       hamiltonian_coefficients)

        print(f"VQE Results:
              Minimum Hamiltonian Energy:{optim_func} at theta: {optim_theta}")
        print(f"Histogram for optimized State:", hist_stats)
        print(f"Solution state: {solution_state}")
        self.max_cut_cluster(distance_matrix=self.hamiltonian, solution_state=solution_state)

if __name__ == '__main__':
    adjacency_matrix = np.array([[1, 0, 0, 0],
                                 [0, 1, 0, 1],
                                 [0, 0, 1, 0],
                                 [0, 1, 0, 1]])

    mc = QuantumMaxCutClustering(
         adjacency_matrix=adjacency_matrix)
    mc.main()

```

从邻接矩阵中可以清楚地看出，顶点 1 和顶点 4 是邻居，因为我们在图中仅有的连接是在它们之间。基于邻接矩阵的距离矩阵如下:

```py
[[0, 1, 1, 1],
[1, 0, 1, 0],
[1, 1, 0, 1],
[1, 1, 1, 0]]

-x output -x

```

基于距离矩阵，所需的哈密顿基如下所示:

```py
Hamiltonian_bases: ['ZZII', 'ZIZI', 'ZIIZ', 'IZZI', 'IIZZ']

VQE Results: Minimum Hamiltonian Energy:-2.9956 at theta: [ 0.99548824-0.0111251   1.01720462  2.00438109]
Histogram for optimized State: {10: 9989, 8: 7, 14: 4}
Solution state: 1010

```

我们可以看到，解决方案状态将顶点 1 和 4 分配到一个簇中，将顶点 2 和 4 分配到另一个簇中(图 [7-4](#Fig4) )。

![../images/495362_1_En_7_Chapter/495362_1_En_7_Fig4_HTML.jpg](../images/495362_1_En_7_Chapter/495362_1_En_7_Fig4_HTML.jpg)

图 7-4

最大割聚类分配

## 量子绝热定理

让我们考虑一个量子系统，其哈密顿量在一段时间 *T* 内从 *H* <sub>0</sub> 缓慢演化到 *H* <sub>*f*</sub> 使得任意时刻的瞬时哈密顿量*H*(*T*)*T*可以表示为初始哈密顿量 *H* ( 【T2 = *H* <sub>0</sub> 和最终哈密顿量*H*(*T*=*T*)=*H*<sub>*f*</sub>如下图:

![$$ H(t)=\left(1-\frac{t}{T}\right){H}_f+\frac{t}{T}{H}_0 $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ35.png)

(7-36)

在任意时刻 *t* 其中 0 ≤ *t* ≤ *T* ，假设瞬时哈密顿量 *H* ( *t* )对应的瞬时本征态由∣*ϕ*<sub>t13】n</sub>(*t*)⟩.

![$$ H(t)\mid {\phi}_n(t)\left\rangle ={E}_n(t)\mid {\phi}_n(t)\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ36.png)

(7-37)

还有，我们来考虑一下*E*<sub>1</sub>(*t*)<*E*<sub>2</sub>(*t*)…。<*E*<sub>*n*</sub>(*t*)…使得没有重复的特征值来避免退化。

如果系统在时间 *t* = 0 处于状态|*ψ*(*t*=0)⟩=∣*ϕ*<sub>*n*</sub>(0)⟩对于某些 *n* )并且哈密顿量在一段时间内从 *H* <sub>0</sub> 缓慢地变化到 *H* <sub>*f*</sub> 那么根据绝热定理，在时间 *t* = *T* 时，系统的状态将是|*ψ*(*t*=*t*)⟩≅|*ϕ*<sub>*n*</sub>(*t*)⟩. 这实质上意味着如果系统在第 n 个最低本征值状态**<sub>*n*</sub>(0)⟩对应于起始哈密顿量*<sub>*o*</sub>)开始， 那么在时间 *T* 时，系统将处于第 *n* 个最低本征值状态*ϕ*<sub>*n*</sub>(*t*)对应于最终哈密顿量 h*<sub>*f*</sub>如果哈密顿量从*非常缓慢地演化 参见图 [7-5](#Fig5) 。***

 *![../images/495362_1_En_7_Chapter/495362_1_En_7_Fig5_HTML.jpg](../images/495362_1_En_7_Chapter/495362_1_En_7_Fig5_HTML.jpg)

图 7-5

绝热演化

量子系统的这一性质对于优化问题是有利的，该优化问题使用哈密顿量的期望作为一组可能的量子态配置的优化目标。例如，我们可能有兴趣找到一个复杂哈密顿量的基态能量*e*T2】1*f*t5】及其对应的本征态∣*ϕ*<sub>1*f*</sub>⟩*h*<sub>*f*</sub>。我们可以使用绝热计算来解决这个问题，从基态∣*ϕ*t20】10⟩开始，基态能量*e*t24】10 为已知的哈密顿量*h*t28】0，然后在一段时间内将量子系统慢慢演化到期望的哈密顿量 *H* <sub>*f*</sub>

## 绝热定理的证明

任意时刻的量子态∣*ψ*(*t*)⟩*t*可以用瞬时哈密顿量 *H* ( *t* )的本征基表示如下:

![$$ \left|\psi (t)\right\rangle =\sum \limits_n{c}_n(t)\mid {\phi}_n(t)\Big\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ37.png)

(7-38)

注意，不仅概率幅度*c*T2】T3】nt5】(*t*)而且基向量∣*ϕ*<sub>*n*</sub>(*t*)都是时间的函数，因为哈密顿量 *H* ( *t* )随时间变化。我们可以用这个表达式代替薛定谔方程中方程 [7-38](#Equ37) 的状态| *ψ* ( *t* )⟩。此外，我们将在每个术语中删除对变量 *t* 的引用，以避免混淆符号。含时薛定谔方程如下:

![$$ i\mathrm{\hslash}\ \dot{\left|\psi (t)\right\rangle}\kern0.5em =H(t)\left|\psi (t)\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ38.png)

(7-39)

| *ψ* ( *t* )⟩的时间导数可以通过微分方程 [7-38](#Equ37) 关于 *t* 的两边得到如下所示:

![$$ \dot{\mid \psi (t)\Big\rangle }=\sum \limits_n\dot{c_n}\mid {\phi}_n\left\rangle +\sum \limits_n{c}_n\mid \dot{\phi_n}\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ39.png)

(7-40)

项*h*(*t*)|*ψ*(*t*)⟩可以用瞬时本征基表示如下:

![$$ H(t)\left|\psi (t)\right\rangle =\sum \limits_nH{c}_n\mid {\phi}_n\left\rangle =\sum \limits_n{c}_n{E}_n\mid {\phi}_n\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ40.png)

(7-41)

将方程 [7-40](#Equ39) 和方程 [7-41](#Equ40) 中的![$$ \dot{\mid \psi (t)\Big\rangle } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq20.png)和*h*(*t*)|*ψ*(*t*)⟩分别代入方程 [7-39](#Equ38) 中的含时薛定谔方程，得到如下:

![$$ i\mathrm{\hslash}\sum \limits_n\dot{c_n}\mid {\phi}_n\left\rangle +i\mathrm{\hslash}\sum \limits_n{c}_n\mid \dot{\phi_n}\right\rangle =\sum \limits_n{c}_n{E}_n\mid {\phi}_n\Big\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ41.png)

(7-42)

如果我们用特征向量∣*ϕ*T2】T3】kt5】(*t*)⟩在方程 [7-42](#Equ41) 的两边做点积，那么我们得到如下:

![$$ i\mathrm{\hslash}\dot{c_k}+i\mathrm{\hslash}\sum \limits_n\left\langle {\phi}_k|\dot{\phi_n}\right\rangle {c}_n={c}_k{E}_k $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equq.png)

![$$ \to i\mathrm{\hslash}\dot{c_k}={c}_k{E}_k-i\mathrm{\hslash}\sum \limits_n\left\langle {\phi}_k|\dot{\phi_n}\right\rangle {c}_n $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equr.png)

![$$ \to i\mathrm{\hslash}\dot{c_k}={c}_k{E}_k-i\mathrm{\hslash}{c}_k\Big\langle \left\langle {\phi}_k|\dot{\phi_k}\right\rangle -i\mathrm{\hslash}\sum \limits_{n\ne k}\left\langle {\phi}_k|\dot{\phi_n}\right\rangle {c}_n $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ42.png)

(7-43)

我们接下来对特征值方程*h*(*t*)∣*ϕ*<sub>*n*</sub>(*t*)⟩=*e*<sub>*n*</sub>(*t*)∣*ϕ*<sub>*n*</sub>(*t*)⟩在方程【中

同样，通过对除了 *n* = *k* 之外的所有*n*=*k*值执行由∣*ϕ*<sub>T3】kt5】(*t*)⟩在方程 [7-38](#Equ37) 两边的点积，我们得到以下:</sub>

![$$ \left\langle {\phi}_k\left|\dot{H}|{\phi}_n\right\rangle +\right\langle {\phi}_k\left|H\dot{\left|{\phi}_n\right\rangle }=\Big\langle {\phi}_k\right|\dot{E_n}\left|{\phi}_n\right\rangle +\Big\langle {\phi}_k\mid {E}_n\dot{\left|{\phi}_n\right\rangle } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equs.png)

![$$ \to \left\langle {\phi}_k\left|\dot{H}|{\phi}_n\right\rangle +{E}_k\right\langle {\phi}_k\dot{\left|{\phi}_n\right\rangle }={E}_n\Big\langle {\phi}_k\dot{\left|{\phi}_n\right\rangle } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equt.png)

![$$ \to \left\langle {\phi}_k\left|\dot{H}|{\phi}_n\right\rangle =\left({E}_n-{E}_k\right)\right\langle {\phi}_k\dot{\left|{\phi}_n\right\rangle } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equu.png)

![$$ \to \Big\langle {\phi}_k\dot{\left|{\phi}_n\right\rangle }=\frac{\Big\langle {\phi}_k\left|\dot{H}|{\phi}_n\right\rangle }{E_n-{E}_k} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ44.png)

将方程 [7-45](#Equ44) 中![$$ \Big\langle {\phi}_k\dot{\left|{\phi}_n\right\rangle } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq21.png)的值代入方程 [7-43](#Equ42) ，得到:

![$$ i\mathrm{\hslash}\dot{c_k}={c}_k{E}_k-i\mathrm{\hslash}{c}_k\Big\langle \left\langle {\phi}_k|\dot{\phi_k}\right\rangle -i\mathrm{\hslash}\sum \limits_{n\ne k}{c}_n\frac{\Big\langle {\phi}_k\left|\dot{H}|{\phi}_n\right\rangle }{E_n-{E}_k} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ45.png)

(7-46)

现在当哈密顿量 *H* ( *t* )慢慢演化时，哈密顿量![$$ \dot{H(t)} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq22.png)的导数会很小。这将使![$$ \Big\langle {\phi}_k\left|\dot{H}|{\phi}_n\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq23.png)的值接近于零，因此我们可以忽略与![$$ \Big\langle {\phi}_k\left|\dot{H}|{\phi}_n\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq24.png)成比例的项。通过丢弃与![$$ \Big\langle {\phi}_k\left|\dot{H}|{\phi}_n\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq25.png)成比例的项，我们得到如下:

![$$ i\mathrm{\hslash}\dot{c_k}={c}_k{E}_k-i\mathrm{\hslash}{c}_k\left\langle {\phi}_k|\dot{\phi_k}\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equv.png)

![$$ \to \dot{c_k}=\frac{1}{i\mathrm{\hslash}}{c}_k\left({E}_k-i\mathrm{\hslash}\left\langle {\phi}_k|\dot{\phi_k}\right\rangle \right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equw.png)

![$$ \to \dot{\frac{c_k}{c_k}}=\frac{1}{i\mathrm{\hslash}\ }\left({E}_k-i\mathrm{\hslash}\left\langle {\phi}_k|\dot{\phi_k}\right\rangle \right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equx.png)

![$$ \to \frac{\frac{d{c}_k(t)}{dt}}{c_k}=\frac{1}{i\mathrm{\hslash}\ }\left({E}_k-i\mathrm{\hslash}\left\langle {\phi}_k|\dot{\phi_k}\right\rangle \right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ46.png)

(7-47)

我们可以将方程 [7-47](#Equ46) 中的方程两边乘以 *dt* ，积分得到*c*<sub>*k*</sub>(*t*)如下图所示。在这方面，积分的极限将从 *t* <sup>'</sup> = 0 到*t*<sup>'</sup>=*t*。

![$$ \underset{c_k(0)}{\overset{c_k(t)}{\int }}\frac{d{c}_k\left({t}^{\prime}\right)}{c_k}=\int \frac{1}{i\mathrm{\hslash}\ }\left({E}_k-i\mathrm{\hslash}\left\langle {\phi}_k|\dot{\phi_k}\right\rangle \right){dt}^{\prime } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equy.png)

![$$ \to {\log}_e{c}_k(t)/{c}_k(0)=\underset{t^{\prime }=0}{\overset{t}{\int }}\frac{1}{i\mathrm{\hslash}\ }\left({E}_k-i\mathrm{\hslash}\left\langle {\phi}_k|\dot{\phi_k}\right\rangle \right){dt}^{\prime } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equz.png)

![$$ \to {c}_k(t)={c}_k(0)\ast \mathit{\exp}\left(\underset{t^{\prime }=0}{\overset{t}{\int }}\frac{1}{i\mathrm{\hslash}\ }\left({E}_k-i\mathrm{\hslash}\left\langle {\phi}_k|\dot{\phi_k}\right\rangle \right){dt}^{\prime}\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equaa.png)

![$$ \to {c}_k(t)={c}_k(0)\ \exp \left(\underset{t^{\prime }=0}{\overset{t}{\int }}\frac{1}{i\mathrm{\hslash}\ }{E}_k\ d{t}^{\prime}\right)\exp \left(-\underset{t^{\prime }=0}{\overset{t}{\int }}\ \left\langle {\phi}_k|\dot{\phi_k}\right\rangle \Big){dt}^{\prime}\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equab.png)

![$$ \to \kern0.5em {c}_k(t)={c}_k(0)\ \exp \left(i\underset{t^{\prime }=0}{\overset{t}{\int }}-\frac{1}{\mathrm{\hslash}\ }{E}_k\ {dt}^{\prime}\right)\exp \left(i\underset{t^{\prime }=0}{\overset{t}{\int }}\ i\left\langle {\phi}_k|\dot{\phi_k}\right\rangle \Big){dt}^{\prime}\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ47.png)

(7-48)

把积分![$$ \underset{t^{\prime }=0}{\overset{t}{\int }}-\frac{1}{\mathrm{\hslash}\ }{E}_k\ {dt}^{\prime } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq26.png)换成*θ*<sub>*k*</sub>(*t*)和![$$ \underset{t^{\prime }=0}{\overset{t}{\int }}\ i\left\langle {\phi}_k|\dot{\phi_k}\right\rangle \Big){dt}^{\prime } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq27.png)换成*γ*<sub>*k*</sub>(*t*)，我们有如下:

![$$ {c}_k(t)={c}_k(0){e}^{i{\theta}_k(t)}{e}^{i{\gamma}_k(t)} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ48.png)

(7-49)

经过一些严格的数学推导，我们终于得出了重要的等式。我们看到，在时间 *t* 的第 *k* 个瞬时本征态的概率幅度基本上与在时间 *t* = 0 的第 *k* 个本征态的概率幅度相同，除非存在由![$$ {e}^{i{\theta}_k(t)}{e}^{i{\gamma}_k(t)} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq28.png)给出的全局相位。于是，*c*<sub>*k*</sub>(*t*)和*c*<sub>*k*</sub>(0)的范数平方本质上是相同的，即|*c*<sub>*k*</sub>(*t【T30)|<sup>2</sup>= |如果我们从初态∣*ψ*(0)=∣*<sub>*k*</sub>(0)⟩)开始绝热演化，那么所有的概率质量都在第 *k* 本征态∣*ϕ*<sub>k</sub>*(0)⟩，于是|*c*<sub>*k*自任一时刻起*t*kth 本征态|*c*<sub>*k*</sub>(*t*)|<sup>2</sup>= |*c*<sub>*k*</sub>(0)|<sup>2【T86</sup></sub>*

 *## 量子近似优化算法

量子近似优化算法(QAOA)是一种利用绝热计算来解决各种优化问题的优化技术。在 QAOA 中，我们根据哈密顿量 *H* <sub>*c*</sub> 来定义我们的优化目标，我们希望优化其期望⟨ *H* <sub>*c*</sub> ⟩。期望值⟨*h*<sub>*c*</sub>⟩通过对应于最小本征值的本征态被最小化，正如我们在前面的 VQE 中看到的。还有，最小期望⟨*h*t20】t21】ct23】⟩等于矩阵的最小特征值*h*t26】t27】ct29】。或者，当状态是对应于最大本征值的本征态时，期望⟨*h*<sub>*c*</sub>⟩最大。

在 QAOA 中，我们利用绝热计算来确定给定哈密顿量期望所需的本征态，以进行优化。对于一个要求我们最小化期望⟨ *H* <sub>*c*</sub> ⟩的哈密顿量 *H* <sub>*c*</sub> 的问题，我们从已知最低的本征值态∣ *ϕ* <sub>0</sub> (0)⟩对应一个初始哈密顿量 *H* <sub>0</sub> 开始，然后演化量子系统，慢慢地向期望的哈密顿量 *H 根据时间 *T* 结束时的绝热定理，我们将处于最低本征值态∣*ϕ*t32】0(*t*)⟩对应期望的哈密顿量 *H* <sub>*c*</sub> 。类似地，对于一个最大化问题，我们将从最大本征值状态∣*<sub>*最大值*</sub> (0)⟩对应于初始哈密顿量*<sub>0</sub>开始，然后在一段时间内将量子系统慢慢演化到期望的哈密顿量*h*<sub>*c*</sub>*t*。绝热定理将确保我们在时间*t*时达到最大本征值状态∣*ϕ*<sub>*max*</sub>(*t*)⟩*h*<sub>*c*</sub>***

 *### 将量子系统演化为客观哈密顿量

如前一节所讨论的，在 QAOA 中我们需要将系统的量子态从初始哈密顿量 *H* <sub>0</sub> 演化到我们感兴趣的最终哈密顿量，即 *H* <sub>*c*</sub> 。我们可以在一段时间 T 内缓慢地演化哈密顿量，使得在任何时间 *t* ≤ *T* ，瞬时哈密顿量由下式给出:

![$$ H(t)=\left(1-\frac{t}{T}\right){H}_o+\frac{t}{T}{H}_c $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ49.png)

(7-50)

给定哈密顿量 *H* ( *t* )随时间变化，哈密顿量 *H* ( *t* )的幺正演化由薛定谔含时方程给出如下:

![$$ i\mathrm{\hslash}\frac{d\mid \psi (t)\Big\rangle }{dt}=H(t)\mid \psi (t)\Big\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ50.png)

(7-51)

如果我们在方程 [7-50](#Equ49) 中哈密顿量 *H* ( *t* )的影响下演化系统，从时间 *t* <sub>1</sub> 到 *t* <sub>2</sub> 关联幺正算符*U*(*t*<sub>2</sub>， *t* <sub>1</sub>

综合方程 [7-52](#Equ51) 两边从 *t* <sub>1</sub> 到 *t* <sub>2、</sub>我们得到如下:

![$$ \underset{\psi \left({t}_1\right)}{\overset{\psi \left({t}_2\right)}{\int }}\frac{d\left|\psi (t)\right\rangle }{\left|\psi (t)\right\rangle }=\underset{t_1}{\overset{t_2}{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equad.png)

![$$ \to {\log}_e\frac{\left|\psi \left({t}_2\right)\right\rangle }{\left|\psi \left({t}_1\right)\right\rangle }=\underset{t_1}{\overset{t_2}{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equae.png)

![$$ \to \left|\psi \left({t}_2\right)\right\rangle =\exp \left(\underset{t_1}{\overset{t_2}{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt\right)\left|\psi \left({t}_1\right)\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ52.png)

(7-53)

从等式 [7-53](#Equ52) 我们看到，变换![$$ \exp \left(\underset{t_1}{\overset{t_2}{\int }}-\frac{i}{\hslash }H(t) dt\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq29.png)将状态从|*ψ*(*t*<sub>1</sub>)⟩变为|*ψ*(*t*<sub>2</sub>)⟩，因此我们需要酉变换*u*(*t*<sub>2</sub>， *t* 

我们感兴趣的是从 *t* = 0 到 *t* = *T* 的酉变换。我们可以将积分的持续时间 *T* 分成持续时间![$$ \Delta  =\frac{T}{p} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq30.png)的 *p* 步，并用 *p* 步的面积之和来代替积分。

![$$ \underset{0}{\overset{T}{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt=\underset{0}{\overset{\Delta  }{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt+\underset{\Delta  }{\overset{2\Delta  }{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt+..\underset{\left(p-1\right)\Delta  }{\overset{p\Delta  }{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ54.png)

(7-55)

由于方程 [7-55](#Equ54) 右侧每个积分的持续时间∏很小，我们可以在持续时间∏内保持哈密顿量不变。利用这种简化，方程 [7-55](#Equ54) 可以写成:

![$$ \underset{0}{\overset{T}{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt=\underset{0}{\overset{\Delta  }{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt+\underset{\Delta  }{\overset{2\Delta  }{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt+..\underset{\left(p-1\right)\Delta  }{\overset{p\Delta  }{\int }}-\frac{i}{\mathrm{\hslash}}H(t) dt $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equaf.png)

![$$ =\underset{0}{\overset{\Delta  }{\int }}-\frac{i}{\mathrm{\hslash}}H\left(\Delta  \right) dt+\underset{\Delta  }{\overset{2\Delta  }{\int }}-\frac{i}{\mathrm{\hslash}}H\left(2\Delta  \right) dt+..\underset{\left(p-1\right)\Delta  }{\overset{p\Delta  }{\int }}-\frac{i}{\mathrm{\hslash}}H\left(p\Delta  \right) dt $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equag.png)

![$$ =-\frac{i\Delta  }{\mathrm{\hslash}}\left(H\left(\Delta  \right)+H\left(2\Delta  \right)+\dots .+H\left(p\Delta  \right)\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ55.png)

(7-56)

使用方程 [7-56](#Equ55) 和 [7-54](#Equ53) ，我们可以写出酉变换 *U* ( *T* ，0)将量子系统从哈密顿量 *H* <sub>0</sub> 演化到期望的哈密顿量 *H* <sub>*c*</sub> 如下:

![$$ U\left(T,0\right)=\exp \left(-\frac{i\Delta  }{\mathrm{\hslash}}\left(H\left(\Delta  \right)+H\left(2\Delta  \right)+\dots .+H\left(p\Delta  \right)\right)\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equah.png)

![$$ \approx \prod \limits_{k=1}^p\exp \left(-\frac{i\Delta  H\left(k\Delta  \right)}{\mathrm{\hslash}}\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ56.png)

根据 Trotter 公式(参见第 [2](2.html) 章)，当∏较小时，我们可以像在方程 [7-57](#Equ56) 中所做的那样，将算子之和的指数近似为指数的乘积。

任意时刻的瞬时哈密顿量*H*(t)*t*由方程 [7-50](#Equ49) 给出为![$$ H(t)=\left(1-\frac{t}{T}\right){H}_o+\frac{t}{T}{H}_c $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq31.png)。我们可以通过查看其在时间间隔的值来离散化哈密顿量，使得我们对哈密顿量进行采样的任何广义时间 *t* 被表示为*t*=*k*∈。因此，在第 *k* 时间步的哈密顿量的一般表示由下面给出:

![$$ H(t)=\left(1-\frac{t}{T}\right){H}_o+\frac{t}{T}{H}_c $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equai.png)

![$$ \to H\left(k\Delta  \right)=\left(1-\frac{k\Delta  }{p\Delta }\right){H}_0+\left(\frac{k\Delta  }{p\Delta }\right){H}_c $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equaj.png)

![$$ \to H\left(k\Delta  \right)=\left(1-\frac{k\Delta  }{p\Delta }\right){H}_0+\left(\frac{k\Delta  }{p\Delta }\right){H}_c $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equak.png)

![$$ \to H\left(k\Delta  \right)=\left(1-\frac{k}{p}\right){H}_0+\frac{k}{p}{H}_c $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ57.png)

(7-58)

利用方程 [7-58](#Equ57) 中的表达式*H*(*k*∈)在方程 [7-57](#Equ56) 中，我们得到酉变换 *U* ( *T* ，0)如下:

![$$ U\left(T,0\right)=\prod \limits_{k=0}^{p-1}\exp \left(-\frac{i\Delta  H\left(k\Delta  \right)}{\mathrm{\hslash}}\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equal.png)

![$$ =\prod \limits_{k=0}^{p-1}\exp \left(-\frac{i\Delta  \left(1-\frac{k}{p}\right){H}_0+i\Delta  \frac{k}{p}{H}_c}{\mathrm{\hslash}}\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equam.png)

![$$ U\left(T,0\right)\kern0.5em \approx \prod \limits_{k=1}^p\exp \left(-\frac{i\Delta  }{\mathrm{\hslash}}\left(1-\frac{k}{p}\right){H}_0\right)\exp \left(-\frac{i\Delta  k}{\mathrm{\hslash}p}{H}_c\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ58.png)

(7-59)

我们可以使用等式 [7-59](#Equ58) 中的幺正变换 *U* ( *T 【T5，0】在 *p* 步中演化量子系统，以从初始哈密顿量 *H* <sub>0</sub> 到 *H* <sub>*c*</sub> 。*

我们没有像方程 [7-59](#Equ58) 中那样使用![$$ \frac{\Delta  }{\hslash}\left(1-\frac{k}{p}\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq32.png)和![$$ \frac{\Delta  k}{\mathit{\hslash p}} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq33.png)，而是将它们参数化为 *β* <sub>* k *</sub> 和 *γ* <sub>* k *</sub> ，并使用经典优化算法来选择最佳的一组 *β* <sub>* k *</sub> 和 *γ* <sub> *k* 由于我们在 *p* 步骤中演化哈密顿量，因此有 2 个 *p* 个数的参数用于酉变换 *U* ( *T* ，0)对应于 *β* <sub>* k *</sub> 和 *γ* <sub>* k *</sub> 的 *p* 集合。我们可以表示所有的 *γ* <sub>* k *</sub> 参数，即 *γ* <sub>1</sub> ， *γ* <sub> 2 </sub> …..， *y* <sub>* p *</sub> ，由矢量![$ \overrightarrow{\gamma} $](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq34.png)和 *β* <sub>* k *</sub> 参数组成，即 *β* <sub>1</sub> ，*β*2</sub>，…*β*T93 因此，专门用于 QAOA 的酉变换可以用参数化形式写成如下:

![$$ U\left(\overrightarrow{\gamma},\overrightarrow{\beta}\right)=\prod \limits_{k=1}^p\exp \left(-i{\beta}_k{H}_0\right)\exp \left(-i{\gamma}_k{H}_c\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ59.png)

(7-60)

### QAOA 的起始哈密顿量

对于一个有 *N* 个量子位的系统，起始哈密顿量*H*<sub>T5】o</sub>被认为是属于每个量子位的泡利矩阵 *X* 的总和。因此，我们可以这样写*H*T12】0:

![$$ {H}_o=\sum \limits_{i=1}^N{X}_i $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ60.png)

(7-61)

哈密顿量的最低本征值态*h*T2】0 是|+⟩<sup>⊗*n*T7】其中∣ + ⟩态是相等的叠加态![$ \frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right) $](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq36.png)。所以，对于极小化问题，我们取起始哈密顿量为![$ \sum \limits_{i=1}^N{X}_i $](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq37.png)，起始状态为其最低本征值状态|+⟩<sup>⊗*n*t13】。将公式 [7-54](#Equ53) 中 *H* <sub>0</sub> 的值代入 exp(*Iβ*<sub>*k*</sub>*H*<sub>0</sub>)中，我们得到如下:</sup></sup>

![$$ \exp \left(-i{\beta}_k{H}_0\right)=\exp \left(-i{\beta}_k\sum \limits_{j=1}^N{X}_j\right)=\prod \limits_{j=1}^N{e}^{-i{\beta}_k{X}_j} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ61.png)

(7-62)

我们可以用乘积形式写出方程 [7-55](#Equ54) ，因为同一个泡利矩阵 *X* 适用于所有量子位，因此它们可以互换。图 [7-6](#Fig6) 是 QAOA 的高级流程图。

![../images/495362_1_En_7_Chapter/495362_1_En_7_Fig6_HTML.jpg](../images/495362_1_En_7_Chapter/495362_1_En_7_Fig6_HTML.jpg)

图 7-6

QAOA 高级图表

以下是量子近似优化算法中最小化哈密顿量 *H* <sub>*c*</sub> 期望值的步骤。

### 起始哈密顿量和初始本征态

如前所述，我们选择起始哈密顿量为![$$ {H}_o=\sum \limits_{i=1}^N{X}_i $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq38.png)，起始状态为对应哈密顿量 *H* <sub>* c *</sub> 的最低本征值状态|+⟩<sup>*n*</sup>。

#### 酉进化

与初始哈密顿量![$$ \exp \left(-i{\beta}_k{H}_0\right)=\prod \limits_{j=1}^N{e}^{-i{\beta}_k{X}_j} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq39.png)相关联的幺正演化不难构建。我们可以对每个量子位使用绕*x*-轴旋转角度 2 * β * <sub>* k *</sub> 的条件旋转来构造变换![$$ \prod \limits_{j=1}^N{e}^{-i{\beta}_k{X}_j} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq40.png)。我们还需要构造与哈密顿量 *H* <sub>* c *</sub> 相关的酉变换![$$ {e}^{-i{\gamma}_k{H}_c} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq41.png)，我们正在最小化其期望值。如果是仅由量子位之间的相互作用组成的 Isling 哈密顿量，那么 *H* <sub>* c *</sub> 可以写成:

![$$ {H}_c=-\sum \limits_{\left\langle i,j\right\rangle }{Z}_i\otimes {Z}_j $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ62.png)

(7-63)

因此，与*<sub>*c*</sub>相关联的酉变换可以写成如下:*

*![$$ \exp \left(-i{\gamma}_k{H}_c\right)=\exp \left(i{\gamma}_k\sum \limits_{\left\langle i,j\right\rangle }{Z}_i\otimes {Z}_j\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ63.png)*

*(7-64)

由于*z*<sub>*I*</sub>⊗*z*<sub>*j*</sub>哈密顿量对每一对量子位( *i* ， *j* )都是对角的，所以它们互换。因此，等式 [7-57](#Equ56) 中的和的指数可以重写为指数的乘积，如下所示:

![$$ \exp \left(-i{\gamma}_k{H}_c\right)=\exp \left(i{\gamma}_k\sum \limits_{\left\langle i,j\right\rangle }{Z}_i\otimes {Z}_j\right)=\prod \limits_{\left\langle i,j\right\rangle}\exp \left(i{\gamma}_k{Z}_i\otimes {Z}_j\right) $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ64.png)

(7-65)

一旦定义了酉变换 exp(*Iβ*<sub>*k*</sub>*H*<sub>0</sub>)和 exp(*Iγ*<sub>*k*</sub>*H*<sub>*c*</sub>)之后，我们就可以通过应用变换 exp(*Iγ*来演化状态

#### 测量和优化

一旦我们通过交替应用变换 exp(*Iγ*<sub>T5】k</sub>*H*<sub>*c*</sub>)和 exp(*Iβ*<sub>*k*</sub>*H*<sub>0</sub>)在 *p* 步骤中演化了量子系统的状态，我们就基于哈密顿量来测量量子位如果哈密顿量 *H* <sub>*c*</sub> 像方程 [7-63](#Equ62) 中那样用泡利 *Z* 矩阵来定义，我们需要在标准计算基中测量量子位。基于测量值，计算哈密顿量期望⟨*h*<sub>*c*</sub>⟩。当参数![$$ \overrightarrow{\gamma},\overrightarrow{\beta} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq42.png)被适当优化时，最小哈密顿量期望⟨*h*<sub>*c*</sub>⟩应该向最小本征值 *H* <sub>* c *</sub> 收敛。一般来说，经典优化器用于根据每一步中的测量来查看期望值⟨*h*<sub>*c*</sub>⟩，并为![$$ \overrightarrow{\gamma},\overrightarrow{\beta} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq43.png)提出下一组最佳参数，就像我们在 VQE 中所做的一样。该过程继续进行，直到优化收敛到![$$ {\overrightarrow{\gamma}}^{\ast },{\overrightarrow{\beta}}^{\ast } $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq44.png)的最优值。

## QAOA 的实施

在本节中，我们通过类`QAOA`为 Isling 哈密顿量实现量子近似优化算法。该类将一个名为`hamiltonian_interactions`的矩阵作为输入，该矩阵定义了相互作用的两个量子位。交互作用的符号也在`hamiltonian_interactions`矩阵中定义。我们从一个已知哈密顿量的最低本征值状态*H*T5】0 开始，然后随着时间 *T* 绝热地将量子系统演化到期望的哈密顿量 *H* <sub>*c*</sub> 。由于在时间 *T* 结束时的绝热演化，我们将处于最低本征值状态 *H* <sub>*c*</sub> 。哈密顿量的最低本征值状态是我们感兴趣的，因为它最小化了哈密顿量的期望 *H* <sub>*c*</sub> ，这是我们的成本目标。

```py
import cirq
import numpy as np

class QAOA:

    def __init__(self, num_elems:int,
                 hamiltonian_type:str,
                 hamiltonian_interactions:np.ndarray):
        self.num_elems = num_elems
        self.hamiltonian_type = hamiltonian_type
        self.hamiltonian_interactions = hamiltonian_interactions
        if self.hamiltonian_type not in ['isling']:
            raise ValueError(f"No support for the
                             Hamiltonian type {self.hamiltonian_type}")
        self.qubits = [cirq.LineQubit(x)
             for x in range(num_elems)]

```

函数`interaction_gate`定义了由 exp(*Iγ*<sub>*k*</sub>*z*<sub>*I*</sub>⊗*z*<sub>*j*</sub>)给出的*z*⊗z 哈密顿量的幺正演化。这是通过使用条件 CZ 门来实现的。

```py
    @staticmethod
    def interaction_gate(q1, q2, gamma=1):
        circuit = cirq.Circuit()
        circuit.append(cirq.CZ(q1, q2)**gamma)
        circuit.append([cirq.X(q2),
                cirq.CZ(q1, q2)**(-gamma), cirq.X(q2)])
        circuit.append([cirq.X(q1),
                cirq.CZ(q1, q2) **(-gamma), cirq.X(q1)])
        circuit.append([cirq.X(q1), cirq.X(q2),
                cirq.CZ(q1, q2) ** gamma, cirq.X(q1), cirq.X(q2)])
        return circuit

```

`target_hamiltonian_evolution_circuit`功能通过将`interaction_gate`应用于所有相互作用的量子位对，为目标哈密顿量*H*<sub>T5】c</sub>的酉演化建立电路。

```py
# Build the Target Hamiltonian based circuit Evolution
    def target_hamiltonian_evolution_circuit(self,gamma):
        circuit = cirq.Circuit()
        # Apply the interaction gates to all the qubit pairs

        for i in range(self.num_elems):

            for j in range(i+1, self.num_elems):
                if self.hamiltonian_interactions[i,j] != 0:
                    circuit.append(self.interaction_gate(
                          self.qubits[i], self.qubits[j],
                                            gamma=gamma))
        return circuit

```

函数`starting_hamiltonian_evolution_circuit`实现了由![$$ \prod \limits_{j=1}^N{e}^{-i{\beta}_k{X}_j} $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq45.png)给出的开始哈密顿酉演化。

```py
# Build the Starting Hamiltonian based evolution circuit
    def starting_hamiltonian_evolution_circuit(self, beta):
        for i in range(self.num_elems):
            yield cirq.X(self.qubits[i])**beta

```

`build_qoaa_circuit`函数使用`starting_hamiltonian_evolution_circuit`和`target_hamiltonian_evolution_circuit`函数为从起始哈密顿量*H*T7】0 到目标哈密顿量 *H* <sub>*c*</sub> 的量子位构建整体幺正演化电路。该函数的参数是与酉进化的 *p* 迭代相关的`gamma_store`和`beta_store`参数。同样，在幺正演化开始之前，被初始化为|0⟩状态的量子位被转换为∣+⟩状态，因为状态|+⟩<sup>⊗*n*t20】是我们需要开始幺正演化的起始哈密顿量![$ {H}_o=\sum \limits_{i=1}^N{X}_i $](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq46.png)的最低本征值状态。</sup>

```py
    def build_qoaa_circuit(self, gamma_store, beta_store):
        self.circuit = cirq.Circuit()
        # Hadamard gate on each qubit to get an
          equal superposition state

        self.circuit.append(cirq.H.on_each(*self.qubits))

        for i in range(len(gamma_store)):
            self.circuit.append(
                 self.target_hamiltonian_evolution_circuit(
                                     gamma_store[i]))
            self.circuit.append(
                self.starting_hamiltonian_evolution_circuit(
                                          beta_store[i]))

```

这里定义的`simulate`函数运行我们定义的量子电路:

```py
    def simulate(self):
        #print(self.circuit)
        sim = cirq.Simulator()
        waveform = sim.simulate(self.circuit)
        return waveform

```

期望电路计算目标哈密顿量 *H* <sub>*c*</sub> 相对于相关特征基的期望。

```py
    def expectation(self,waveform):

        expectation = 0
        prob_from_waveform = (np.absolute
                  (waveform.final_state))**2
        #print(prob_from_waveform)
        for i in range(len(prob_from_waveform)):
            base = bin(i).replace("0b", "")
            base = (self.num_elems - len(base))*'0' + base
            base_array = []
            for b in base:
                if int(b) == 0:
                    base_array.append(-1)
                else:
                    base_array.append(1)

            base_array = np.array(base_array)
            base_interactions = np.outer(base_array, base_array)
            expectation =+
         prob_from_waveform[i]*np.sum(np.multiply(
                   base_interactions,
                   self.hamiltonian_interactions))
        return expectation

```

已经从理论上和实验上验证了选择 *p* = 1 给出了所需哈密顿演化的足够好的近似。因为对于 *p* = 1，我们只需要优化两个参数，而不是使用优化器，所以我们对`beta`和`gamma`的参数值执行网格搜索，为它们选择最佳值。

```py
    def optimize_params(self, gammas, betas, verbose=True):
        expectation_dict = {}
        waveforms_dict  = {}
        for i, gamma in enumerate(gammas):
            for j, beta in enumerate(betas):
                self.build_qoaa_circuit([gamma],[beta])
                waveform = self.simulate()
                expectation = self.expectation(waveform)
                expectation_dict[(gamma,beta)] = expectation
                waveforms_dict[(gamma,beta)]
                      = waveform.final_state
                if verbose:
                    print(f"Expectation
                          for gamma:{gamma},
                          beta:{beta} = {expectation}")
        return expectation_dict, waveforms_dict

```

`main`函数将所有这些放在一起，并对通过网格搜索函数`optimize_params`定义的所有对`gammas`和`betas`执行酉进化和随后的期望计算。最后，我们选择称为`beta`和`gamma`的参数，它们最大程度地最小化了哈密顿量 *H* <sub>*c*</sub> 的期望值。

```py
    def main(self):
        gammas = np.linspace(0, 1,50)
        betas = np.linspace(0, np.pi,50)
        expectation_dict,waveform_dict = self.optimize_params(
                                                    gammas, betas)
        expectation_vals = np.array(
                    list(expectation_dict.values()))
        expectation_params = list(expectation_dict.keys())
        waveform_vals = np.array(list(waveform_dict.values()))
        optim_param = expectation_params[
                                 np.argmin(expectation_vals)]
        optim_expectation = expectation_vals[
                                         np.argmin(expectation_vals)]
        optim_waveform = waveform_vals[
                                  np.argmin(expectation_vals)]
        optim_waveform_probs = [np.abs(x)**2 for x
                               in optim_waveform]
        optim_eigen_state = np.argmax(optim_waveform_probs)
        optim_eigen_state =
               bin(optim_eigen_state). replace("0b", "")
        optim_eigen_state = "0"*(self.num_elems
               – len(optim_eigen_state) +  optim_eigen_state
        print(f"Optimized parameters\n")
        print(f" gamma,beta = {optim_param[0]}
                               ,{optim_param[1]}")
        print(f"Expectation = {optim_expectation}")

        print(f"Waveform probability = {
              [np.abs(x)**2 for x in optim_waveform]} ")
        Print(f”Lowest Eigen value State : {optim_eigen_state}”)
        return expectation_dict

if __name__ == '__main__':
    hamiltonian_interaction = np.array([[0,-1,-1,-1],
                                        [0,0,-1,-1],
                                        [0,0,0,-1],
                                        [0,0,0,0]])
    qaoa_obj = QAOA(num_elems=4,
                    hamiltonian_type='isling',
                    hamiltonian_interactions=hamiltonian_interaction)
    expectation_dict = qaoa_obj.main()

```

作为说明的一部分，我们将使用一个四个量子位的系统，其中所有的量子位相互作用，我们将得到一个 Isling 模型哈密顿量来优化。我们通过`hamiltonian_interaction`输入这些信息，其中每一对交互都被捕获一次。最低的哈密顿能量出现在所有量子位一致的哈密顿量的本征态中，即∣0000⟩态和∣1111⟩态。让我们看看 QAOA 想出了什么:

**输出**

```py
Optimized parameters
 gamma,beta = 0.12244897959183673, 1.6669675304762166
Expectation = -2.237522542476654
Waveform probability = [0.3729205063992005, 0.009119188393314437, 0.009119186970336424, 0.030200931372814432, 0.009119188393314437, 0.03020092619364334, 0.03020093655198597, 0.009119185547358521, 0.009119188393314437, 0.03020094173115795, 0.03020094173115795, 0.009119188393314437, 0.030200946910330373, 0.009119189816292561, 0.009119191239270796, 0.3729204336014078]

Lowest Eigen value State : 0000

```

我们可以看到，在对应于期望值-2.23 的最小值的波形中，∣0000⟩和∣1111⟩这两个州的概率最大，为 0.3729，这与预期结果一致。我们打印两个状态中的一个作为最低特征值状态。

## 量子随机行走

量子随机行走是一种随机行走实现，它利用了基于哈密顿图的量子进化。在随机游走的最后，我们得到的是一个与图的顶点相关的概率振幅向量。与经典的随机行走不同，量子随机行走是基于概率幅度的，在经典的随机行走中，行走者以一定的概率移动到一个顶点。此外，量子随机游动不像经典随机游动那样收敛到任何极限分布。叠加和干涉导致了量子和经典无规行走之间的巨大差异。总的来说，量子随机漫步比经典随机漫步传播得更快，并且具有更快的命中时间。击打时间 *h* <sub>AB</sub> 定义为行走者从 vetex A 开始第一次到达顶点 B 所需的预期时间。回到哈密顿图 *H* <sub>*G*</sub> 对于一个量子随机游走，一般是一个邻接矩阵 *A* 。有时添加单位矩阵 *I* 很方便，这样图的每个顶点都有一条边。这样的图叫做*完全图*。在这种情况下，哈密顿图由下面给出:

![$$ {H}_G=A+I $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ65.png)

(7-66)

一旦我们有了哈密顿量 *H* <sub>*G*</sub> 图，我们就可以用适当数量的量子位来定义量子系统。例如，如果我们在图`,`中有 *N* 个顶点，那么我们可以有一个*N*=*log*<sub>2</sub>(*N*)量子位的量子系统。然后根据薛定谔方程演化出 n 个量子比特的量子系统。

![$$ i\mathrm{\hslash}\frac{d\mid \psi (t)\Big\rangle }{dt}={H}_G\mid \psi (t)\Big\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ66.png)

(7-67)

状态∣ *ψ* ( *t* )⟩将包含图中每个顶点的概率幅度。我们通常将归一化的普朗克常数取为 1，并使用酉变换来演化系统。

![$$ U(t)={e}^{-i{H}_Gt}. $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ67.png)

(7-68)

常数哈密顿量的薛定谔方程的解由

![$$ \mid \psi (t)\left\rangle =U(t)\mid \psi (0)\right\rangle $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ68.png)

(7-69)给出

如前所述，状态∣ *ψ* ( *t* )⟩应该包含图中每个顶点在时间 *t* 的概率幅度。

酉变换可以通过使用适当的门设计量子电路来实现。在这点上，必须注意，将酉算符定义为哈密顿量的指数可能难以实现，除非哈密顿量是对角的。事实证明，使用变换*q*=*h*<sup>⊗*n*</sup>其中 *H* 是哈达玛变换，拥有一个完整的图有助于简化对角化。哈密顿量和酉算符的对角化由下面给出:

![$$ {H}_{GD}={Q}^{\dagger }{H}_GQ $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equan.png)

![$$ {U}_D(t)={Q}^{\dagger }\ {e}^{-i{H}_Gt}Q. $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ69.png)

(7-70)

幺正算符包含哈密顿量的演化时间 *H* <sub>*G*</sub> 。这可以被视为图量子行走算法的超参数。

## 量子随机漫步实现

在本节中，我们将使用 Cirq 实现量子随机漫步。我们将使用四个顶点的完整图形(图 [7-7](#Fig7) )并使用条件泡利 *Z* 门为哈姆达对角化酉变换![$$ {U}_D(t)={Q}^{\dagger }\ {e}^{-i{H}_Gt}Q $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_IEq47.png)创建电路。

![../images/495362_1_En_7_Chapter/495362_1_En_7_Fig7_HTML.jpg](../images/495362_1_En_7_Chapter/495362_1_En_7_Fig7_HTML.jpg)

图 7-7

带顶点的完全图

这是通过函数`diagonal_exponential`实现的。这个函数的输入是哈密顿量的本征值 *H* <sub>*G*</sub> 和演化的时间 *t* 。

我们执行量子随机漫步，持续时间从 *t* 到 *t* = 4 秒。

```py
import cirq
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx

class GraphQuantumRandomWalk:

    def __init__(self, graph_hamiltonian, t, verbose=True):
        self.graph_ham = graph_hamiltonian
        self.num_vertices = self.graph_ham.shape[0]
        self.num_qubits = int(np.log2(self.num_vertices))
        self.qubits = [cirq.LineQubit(i)
          for i in range(self.num_qubits)]
        self.t = t
        self.verbose = verbose

    @staticmethod
    def diagonal_exponential(qubits, eigen_vals, t):
        circuit = cirq.Circuit()
        q1 = qubits[0]
        q2 = qubits[1]
        circuit.append(cirq.CZ(q1, q2) **
                (-eigen_vals[-1] * t / np.pi))
        circuit.append([cirq.X(q2), cirq.CZ(q1, q2) **
                (-eigen_vals[-2] * t / np.pi), cirq.X(q2)])
        circuit.append([cirq.X(q1), cirq.CZ(q1, q2) **
                (-eigen_vals[-3] * t / np.pi), cirq.X(q1)])
        circuit.append(
            [cirq.X(q1), cirq.X(q2), cirq.CZ(q1, q2) **
                (-eigen_vals[-4] * t / np.pi),
                  cirq.X(q1), cirq.X(q2)])
        return circuit

```

基于哈密顿量和演化时间 *t* 的幺正演化电路构建在此处所示的`unitary`函数中:

```py
    def unitary(self):
        eigen_vals, eigen_vecs = np.linalg.eigh(self.graph_ham)
        idx = eigen_vals.argsort()[::-1]
        eigen_vals = eigen_vals[idx]
        eigen_vecs = eigen_vecs[:, idx]
        if self.verbose:
            print(f"The Eigen values: {eigen_vals}")

        self.circuit = cirq.Circuit()
        self.circuit.append(cirq.H.on_each(self.qubits))
        self.circuit += self.diagonal_exponential(self.qubits, eigen_vals, self.t)
        self.circuit.append(cirq.H.on_each(self.qubits))

```

我们使用函数`simulate`模拟随机游走电路，并使用 Cirq 的`final_state`功能直接获得最终状态，而不是通过测量获得不同基础上的概率分布。

```py
    def simulate(self):
        sim = cirq.Simulator()
        results = sim.simulate(self.circuit).final_state
        prob_dist = [np.abs(a) ** 2 for a in results]
        return prob_dist

    def main(self):
        self.unitary()
        prob_dist = self.simulate()
        if self.verbose:
            print(f"The converged prob_dist: {prob_dist}")
        return prob_dist

if __name__ == '__main__':
    graph_hamiltonian = np.ones((4, 4))
    time_to_simulate = 4
    steps = 80
    time_trace = []
    prob_dist_trace = []
    for t in np.linspace(0, time_to_simulate):
        gqrq = GraphQuantumRandomWalk(
               graph_hamiltonian=graph_hamiltonian, t=t)
        prob_dist = gqrq.main()
        time_trace.append(t)
        prob_dist_trace.append(prob_dist)
    prob_dist_trace = np.array(prob_dist_trace)
    plt.plot(time_trace, prob_dist_trace[:, 0])
    plt.show()
    rows, cols = np.where(graph_hamiltonian == 1)
    edges = zip(rows.tolist(), cols.tolist())
    gr = nx.Graph()
    gr.add_edges_from(edges)
    nx.draw(gr,node_size=4)
    plt.show()

-x- output -x-

The Eigen values: [ 4.00000000e+00 -1.23259516e-32 -3.42450962e-16 -9.89816667e-16]

The converged prob_dist: [0.2658776231786675, 0.24470737592319214, 0.2447074054083629, 0.2447074054083629]

```

之前所示的收敛概率分布是基于时间周期 *t* =0.75 的哈密顿演化。一般来说，收敛的概率分布取决于模拟的时间 *t* ，如图 [7-8](#Fig8) 所示。基于哈密顿量的演化时间，顶点 0 的概率不仅不同，而且以周期性模式振荡。它从概率 1 开始，因为我们从分配给状态∣00⟩的所有概率质量开始，这表示顶点 0，然后概率降低到大约 0.25 的最低值，这对应于等概率状态。振荡本质上是正弦的。

![../images/495362_1_En_7_Chapter/495362_1_En_7_Fig8_HTML.jpg](../images/495362_1_En_7_Chapter/495362_1_En_7_Fig8_HTML.jpg)

图 7-8

不同时间模拟的顶点 0 的概率

哈密顿量 *H* <sub>*g*</sub> 图的特征值为[4，0，0，0]，这使得对角酉算子*U*<sub>*D*</sub>(*t*)看起来如下:

![$$ \left[\begin{array}{cccc}{e}^{-i4t}&amp; 0&amp; 0&amp; 0\\ {}0&amp; 1&amp; 0&amp; 0\\ {}0&amp; 0&amp; 1&amp; 0\\ {}0&amp; 0&amp; 0&amp; 1\end{array}\right] $$](../images/495362_1_En_7_Chapter/495362_1_En_7_Chapter_TeX_Equ70.png)

(7-71)

复杂的指数*e*T2*I*4*t*T7】导致我们在图 [7-8](#Fig8) 中看到的振荡行为。

## 摘要

就这样，我们来到了本章和本书的结尾。书中讨论的主题是先进的量子优化技术，可以改变今天在不同领域进行优化的方式。这些量子优化技术的好处是，它们不需要完美的量子计算机来执行。由于这些优化技术在某种程度上是近似的方法，它们非常适合有噪声的近期量子计算机。建议读者详细阅读本章中的主题，以便从这种有趣且令人兴奋的基于量子的优化范例中获取最大收益。我们祝愿你在接下来的努力中一切顺利。****