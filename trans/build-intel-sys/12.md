# 十二、智能运行时

智能运行时将智能付诸行动。它负责与智能系统的其余部分接口，收集执行系统智能所需的信息，加载和解释智能，并将智能的预测连接回系统的其余部分。

从概念上讲，智能运行时可能看起来像这样:

```py
Intelligence theIntelligence =
                InitializeIntelligence(<intelligence data file>,
                                <server address>,
                                <etc...>);

Context theContext =
                GatherContext(<sensors>,
                                <content>,
                                <user history>,
                                <other system properties>,
                                <etc...>);

Prediction thePrediction =
        ExecuteIntelligence(theIntelligence, theContext);

UpdateTheExperience(thePrediction);

```

原则上这很简单，但是，像大多数好东西一样，它在实践中需要大量的复杂性。

本节涵盖了智能运行时将处理的主要元素:

*   收集上下文。
*   构建特征。
*   加载模型。
*   在上下文/特征上执行模型。
*   将结果预测与经验联系起来。

## 语境

智能运行时中的上下文由智能可能用来做出决策的所有数据组成。例如:

*   如果智能系统试图确定喷水灭火系统是否应该运行，上下文可能包括。
    *   自洒水喷头上次运行以来的时间。
    *   未来几天的天气预报(会不会下雨)。
    *   过去几天的降雨量。
    *   用户拥有的景观类型。
    *   一天中的时间。
    *   温度。
    *   潮湿。
    *   诸如此类。
*   如果智能系统在图像中寻找猫，上下文可能包括。
    *   原始图像数据(像素的 RGB 强度)。
    *   关于如何捕捉图像的元数据(曝光和帧速率、时间、缩放)。
    *   图像来自的位置。
    *   诸如此类。
*   如果智能系统试图告诉用户是否应该离开他们的计算机休息一会儿，上下文可能包括。
    *   上次休息后的时间。
    *   用户在休息后所做的活动(击键和鼠标移动的次数)。
    *   用户活跃程度的指示。
    *   距离用户下一次会议的时间量(根据他们的日历)。
    *   用户当前正在交互的应用的名称。
    *   诸如此类。

上下文可以是任何计算机可处理的信息，如 URL、来自某个嵌入式设备的传感器读数、数字图像、电影目录、用户过去行为的日志、一段文本、医疗设备的输出、商店的销售收据、程序的行为等等。

这些可能有助于决定智能系统应该做什么。事实上，环境通常是智能用来做决定的事物的超集。

一个好的上下文将:

*   包含足够的信息，使情报有效。
*   包含足够的信息让智能成长和适应。
*   包含足够的信息，让智能系统的指挥者追踪错误。
*   足够有效地在运行时收集情报。
*   足够紧凑，可用于遥测。

显然，这是有所取舍的。更完整的上下文为智能提供了更大的潜力，但它也可能遇到工程和操作限制，需要额外的 CPU 和内存使用以及网络带宽，并引入延迟和增加数据大小。

## 特征抽出

收集这些上下文变量可能需要大量的工作。但这并不是过程的结束。还有另一层代码将这些变量转换成智能需要的表示。这个额外的层通常被称为“特征提取”或“特征化”，是机器学习系统的一个常见部分。

这对于智能实现很重要，原因有很多:

*   从上下文产生特性的代码需要在运行时运行。也就是说，它需要高效和可靠。
*   这些代码通常是技术性的、计算量大的、数学化的，并且对于没有丰富数据处理经验的人来说不直观。
*   智能创造者会想要不断地改变代码的功能；事实上，他们可能需要定期改变它来继续发展智力。
*   该代码与智能紧密耦合，并且特征提取代码和智能(模型)绝对必须保持同步——当执行智能时，用于构建智能的特征提取代码的确切版本也必须在运行时使用。

由于这些因素，必须仔细规划特征提取。一些最佳实践包括:

*   拥有广泛的特征提取代码测试集。这应包括:
    *   提取器的单元测试。
    *   性能测试，以确保代码满足 CPU 和 RAM 的要求。
    *   针对一组已知的上下文定期执行特征提取代码的测试(可能每天，可能在每次签入时)，并将输出与已知的基准进行比较。工程师和智能创造者应该检查输出的任何变化，以确保它是预期的。
    *   确保特征提取代码在运行时(当用户与之交互时)所做的事情与它在智能创建环境中所做的事情(当它被用于创建模型时)完全相同的测试。
*   将版本信息编码在智能和特征提取代码中，并让运行时验证它们是否同步。
*   具有在整个应用的带外改变特征提取代码的能力；例如，通过在每次模型更新时发送新版本的特征提取代码。
*   开发一个生命周期，将特征提取的变化从智能创建者转移到工程师，再到部署。生命周期应该允许智能创造者在评估变化时快速行动，并且部署给用户的代码质量应该很高。

## 模型

模型是智能的表示(我们将在接下来的章节中讨论表示选项)。现在，把模型想象成一个数据文件。在一些智能系统中，模型每隔几天就要更换一次。在一些系统中，它们每隔几分钟就要更换一次。

变化率将取决于以下因素:

1.  系统获得足够数据来改进模型的速度。
2.  构建新模型需要多长时间。
3.  销售新型号要花多少钱。
4.  相对于成功标准，变革的必要性有多大。

一般来说，模型会比更大的程序变化得更快。有效的运行时将:

*   允许模型被容易地更新(也就是说，不需要重新启动整个系统)。
*   确保它使用的模型是有效的，并且所有组件(特征提取器、模型、上下文)是同步的。
*   使从模型错误中恢复变得容易(通过回滚到以前的版本)。

模型的一个关键考虑因素是它们在磁盘和 RAM 中占用的空间量。如果不加检查，机器学习可以产生相当大的模型。但是，如果需要的话，总是可以进行权衡的，例如在模型大小和准确性之间。

## 执行

执行模型是要求模型根据上下文(和相关特征)进行预测的过程。

在最简单的情况下，当只有一个模型并且它存在于客户机上时，执行一个模型就像将特性加载到一个数组中并对现成的模型执行引擎进行函数调用一样简单。有很多库可以执行机器学习可以构建的几乎所有类型的模型，在大多数情况下，这些库完全可以接受——所以大多数时候，你甚至不需要编写太多代码来加载和执行模型。

当然，在某些情况下，这些库是不可接受的。例子包括当 RAM 或 CPU 是一个约束时；或者当执行发生在具有特殊硬件(如 GPU 或 FPGA)的设备上，而库没有利用这些硬件时。

另一种执行形式涉及在服务器上运行的模型。在这些情况下，客户端需要捆绑上下文(或特性)的一些(紧凑)表示，将它们发送到服务器，并等待响应，处理所有需要的协调，以正确考虑调用的延迟并防止它导致糟糕的用户体验。

当系统有不止一个模型时(这是经常发生的情况)，执行需要执行每个模型，收集它们的结果，并将它们组合成一个最终的答案。有许多方法可以做到这一点，包括:

*   平均他们的结果。
*   取最高(最确定)的结果。
*   有一些关于选择哪一个值得信任的上下文的规则(例如，一个模型在 90210 确定房价，但在其他地方都很糟糕，另一个模型适用于公寓，但不适用于独户住宅)。
*   具有结合了其他模型的输出的模型。

第四部分“创造智能”中的章节将更详细地讨论模型组合以及这些(和其他)方法的优缺点。

## 结果

执行智能产生一个答案。也许智能输出 0.91，这表示无论智能在说什么都有 91%的可能性。实现必须利用这一点来影响智能体验将做什么。例如，它可能会将该值与阈值进行比较，如果该值足够高(或足够低)，则启动提示，或自动执行某些操作，或注释一些信息——无论智能体验想要做什么。

### 智力不稳定

使用智能的原始输出可能有风险，因为智能本质上是不稳定的。例如:

拍一张奶牛的数码照片。使用奶牛检测器模型来预测图像包含奶牛的概率，输出可能很高，可能是 97.2%。

现在等一天。后端系统具有新的训练数据，构建新的奶牛检测器模型，将其分发给运行时。将更新的模型应用于同一张奶牛图片，概率估计几乎肯定会不同。差异可能很小，比如 97.21%(与原始的 97.2%相比)，也可能相对较大，比如 99.2%。新的估计可能更准确，也可能不太准确。但是在两种不同版本的智力之间，这种估计是非常非常不可能的。

环境的微妙变化也会产生类似的影响。例如，把你的相机对准一头奶牛，尽可能快地连续拍摄两张数码照片。对于人类来说，奶牛在两幅图像中看起来是一样的，背景看起来是一样的，照明看起来也是一样的——“奶牛检测器”模型应该在第一幅图像上输出与第二幅图像相同的概率估计。据一个人类说。

但是对于一个模型来说，图像可能看起来非常不同:数字传感器引入了噪声，图像之间的噪声分布将是不同的(导致人眼很难看到的小斑点)；奶牛可能在一只眼睛里眨了眨，而在另一只眼睛里却没有；风可能吹过，改变了树叶阴影的位置；摄像机的位置可能发生了细微的变化；相机的自动对焦或曝光校正可能对图像做了稍微不同的事情。

由于所有这些，智能可能会对两幅图像做出不同的估计。可能一个是 94.1%，另一个是 92.7%。

也许这种改变对智能体验来说没什么大不了的，但也许确实如此。

试图假装机器学习系统中不存在不稳定性会导致效率更低(或者完全糟糕)的智能体验。

### 智能 API

为了解决智能输出的不稳定性，将智能封装在一个接口之后通常是有帮助的，该接口公开了实现系统目标所需的最少量的信息:

*   在处理一个概率的时候，可以考虑扔掉一堆分辨率:四舍五入 92.333534%到 90%。
*   考虑将概率转化为分类:不要说“45%有一头牛”，而是说“没有一头牛。”
*   考虑量化预测:不要说“图像中坐标为 14，92 处有一头奶牛”，而是说“图像左侧有一头奶牛。”

实现这些类型的转换所需的阈值和策略与智能紧密相关，应该包含在每次更新的模型中。

虽然这些实践确实有所帮助，使模型的输出更加稳定，并提供了模型内部工作的某种程度的封装，但它们并不完美。例如，假设奶牛检测器 81%确定一帧中有一头奶牛。该模型的阈值为 80%。因此，系统创建了一个“这里有一头牛”的分类，并点亮了一个 UX 元素。

然后在下一帧，奶牛检测器 79.5%确定有奶牛存在，用户体验就消失了。这看起来真的很糟糕。

一个设计良好的 API，结合一个被设计来最小化缺陷的体验，都是有效的智能体验所必需的。

## 摘要

智能运行时负责:收集系统的上下文；将这种环境转换成一种与智能一起工作的形式；执行构成智能的各种组件；结合情报结果，在情报和经验之间建立良好的界面；并且使用智能的输出来影响用户体验。

智能运行时将处理的一些关键组件包括:

*   上下文，包括与在智能系统中做出正确决策相关的所有信息。
*   特性(和特性提取代码)，将上下文转换成与包含系统智能的特定模型兼容的形式。
*   代表智能的模型通常包含在数据文件中，这些数据文件在智能系统的生命周期中会相对频繁地更改。
*   执行引擎，对要素执行模型并返回预测。有许多很棒的库来支持执行模型，但是这些库通常需要被包装以结合智能；对于独特的执行环境，有时需要替换它们。
*   结果，也就是智能的预测。保持原始结果的私密性并创建一个智能 API 是一个很好的实践，该 API 公开最少的信息来增强智能体验，同时对随时间的变化保持健壮。

一个有效的智能运行时将使追踪错误变得容易；将在运行时以与在智能创建环境中相同的方式执行；将支持对模型和特征提取的简单改变；并且使系统的各个部分很难不同步。

## 供思考…

阅读完本章后，您应该:

*   能够设计执行智能的运行时，并使用它来增强用户体验。
*   了解如何构建智能运行时以支持智能创新并支持智能实现的其他组件。

你应该能够回答这样的问题:

*   智能呼叫的上下文和机器学习模型使用的特征之间有什么区别？

想想你最近使用的智能系统。

*   在它发出的情报呼叫的上下文中，可能是什么类型的信息？
*   从高层次上来说，通过这些步骤，从该环境到影响用户的体验(发明任何你需要的关于系统如何工作的细节)。
*   有哪些方法可以封装这个系统的智能，以减轻微小的智能变化对用户的影响？