# 7.监视

> 工作软件是进度的主要衡量标准。—agilemanifesto.org/principles

在第 3 章:持续交付中，我们谈到了持续集成和持续部署等技术，这些技术确保新的工作软件不仅仅是频繁地交付，而是持续地交付。敏捷宣言的作者在这个原则中明确指出，拥有实际工作的软件比拥有大量描述一些软件系统的文档更有价值，这些软件系统还没有集成到足以运行的程度。因此，在任何软件项目中，让某个东西快速运行，然后保持它运行，同时递增地添加功能是至关重要的。做这件事的一些技巧在第 [1](01.html) 章:早期交付中有描述。

但是我们相信，拥有工作软件虽然重要，但不足以衡量你的进步。如果您不真正知道您的工作软件在工作时做了什么——如果您没有在您的工作软件中构建度量——拥有工作软件就像谚语中所说的树在森林里倒下，周围没有人听到它倒下。很可能软件正以无人知晓的方式坠落。

## 监控工作软件

作为发布工作软件的开发过程的一部分，您应该有一个计划来收集作为工作软件一部分的遥测数据。这种遥测技术不仅可以用于确保软件按照对用户的承诺运行，还可以指导未来功能的开发，并衡量您交付的产品是否真正满足企业和客户的需求。有四个问题你应该努力用你的遥测来回答。首先，软件是真的如设计的那样正常工作还是意外失败？第二，你向用户展示的数据有多准确？第三，你试图达到的商业目标是什么，你能衡量这些目标是否真的达到了吗？最后，你的用户有什么需求，你在衡量这些需求的满足程度吗？

### 监控和隐私

我们建议可以用保护用户隐私的方式监控工作软件。越来越多的客户要求这样做，这反映在世界各地通过的法律和法规中，如通用数据保护法规或 GDPR。我们将在本章中讨论在尊重用户隐私的同时可以用来监控的机制。然而，在未来，甚至这种“隐私感知”监控也可能需要由您的用户在某些司法管辖区内选择。

### 一个示例系统:离开的时间

作为激发本章讨论的一个例子，我们简单描述一下 Eric 在 Cortana 团队工作时开发的一个系统。这项功能被称为“离开时间”(TTL)，并被集成到 iPhone 的 Outlook 移动客户端中。苹果邮箱和谷歌收件箱也有类似的功能。该功能的工作原理如下:如果您在日历上安排了一次会议，并为会议添加了一个可以在地图上找到的位置，并且如果您与 Outlook mobile 客户端共享了位置数据，则 TTL 会计算您当前所在位置与下一次会议之间的行驶方向和长度，并在您的电话上提醒您在正确的时间离开，以便您可以前往会议并准时到达。TTL 会根据当前的交通状况和您当前位置与下一个会议地点之间的预期行驶时间来完成这项工作。因此，如果你在 3 点安排了一个会议，在当前的交通状况下还有 20 分钟，TTL 会在 2:30 提醒你，你最好开始开车去你的下一个会议，以准时到达那里，并向你显示会议的当前交通地图。如果会议就在附近，并且不需要大量的旅行时间，TTL 只会给你标准的即将到来的会议提醒，而没有交通信息。

该系统在 Outlook 移动客户端中有一些代码，但是大部分业务逻辑和代码作为一组微服务在服务器上运行。它与存储在服务器上的日历数据进行交互，以获取有关日历变化的信息，其中可能包括要跟踪的位置。它与 Bing 的交通和路由系统进行交互，为即将到来的会议获取有关当前交通状况的信息。它与 iPhone 上的通知服务互动，在适当的时候触发警报。当用户在 Outlook 移动客户端中激活或停用该功能时，iPhone 应用程序还与微服务进行交互，以打开或关闭该功能。

监控对于任何应用程序来说都是必不可少的，以充分了解它是否按预期工作，在这个项目中，这一点尤其重要，因为系统中有如此多的移动部件。此外，许多逻辑操作发生在几个执行表面上，例如，要成功打开该功能，需要成功发生以下情况:代码必须在手机上的 Outlook mobile 客户端上运行，用户必须同意将位置数据共享给应用程序，服务器上的代码必须运行以打开该功能，服务器上的附加代码必须启动以扫描即将到来的日历事件以查找位置，代码必须开始运行以侦听会议的未来更改。

### 基于活动的监控

离开系统的时间有成千上万行代码，有成千上万种方法。它被分割在客户端代码和几个微服务上。我们是如何监控它的？

我们使用了一种叫做基于活动的监控技术。我们首先定义了大约 50 个代表系统中重要功能块的活动类。这些活动的一些例子包括:

*   RegisterForTTL:跟踪用户注册开始接收离开时间通知的时间

*   UnregisterForTTL:跟踪用户何时关闭时间

*   StartTrackingEvent:跟踪何时开始监控带有位置的即将到来的事件的行程时间

*   StopTrackingEvent:跟踪具有被监视位置的即将到来的事件何时被删除或不再有可路由到的位置

*   processmeetingwhuserlocationchanged:跟踪某个位置的即将发生的事件的位置何时发生变化

*   ChangeTransportationMode:跟踪 Outlook mobile 中的用户何时更改他们通常的出行方式首选项-如果用户使用公共汽车和火车出行，他们可以选择开车或乘坐公交来获取路线

*   SendTTLNotification:跟踪何时触发离开时间通知并将其发送给用户

活动包装了系统中这些逻辑功能单元的执行。类似“RegisterForTTL”的活动将在 iPhone 上开始，并通过几个微服务继续，然后在微服务成功完成后返回 iPhone。TraceID 用于跟踪用户的请求，从他们的手机通过各种后端系统，然后返回到手机——这个 TraceID 只是一个 GUID(一个全局唯一标识符，是每个用户请求的唯一字符串，看起来像“360 c 4783-E414-4 CEC-A114-8513 aa 6 a 8 CCE”)，它在整个系统中跟踪特定的操作。在 C#中，活动对操作的包装如下所示:

```py
Activities.RegisterForTTL.ExecuteAsync(async () =>
{
// Perform the operation
//
 return ...;
});

```

每个 activity 类都有自己唯一的标识符、一个长名称(如 ChangeTransportationMode)和一个较短的缩写名称(ChgTranMode)。活动也可以嵌套。例如，RegisterForTTL (RegForTTL)活动中可能嵌套了几个其他相关活动，这些活动是第一次打开该功能时发生的——StartTrackingEvent(StTrkEvnt)活动是潜在嵌套活动的一个示例，当“离开时间”功能打开时，如果发现即将到来的会议的位置在时间上足够近，并且距离用户的当前位置足够远，则需要开始对其进行跟踪，以确定何时提醒用户。当活动嵌套时，系统使用更短的缩写名称来创建所谓的“活动向量”，它表示活动的嵌套，因此类似“RegForTTL > StTrkEvnt”的内容显示 StartTrackingEvent 活动(StTrkEvnt)是在 RegisterForTTL 活动(RegForTTL)中调用的。这些活动向量与活动类记录的每个跟踪一起发出。

此外，我们的微服务 API 中的每个 REST 入口点也被包装在一个活动中。这允许您从服务器上调用 REST API 开始，通过成功(或不成功)的执行来跟踪执行。大约有另外 25 个系统的入口点也是用活动包装的。

然后，活动会将每个活动包装的操作执行期间发生的事件记录到基于文本的日志记录系统中。活动将跟踪的事件如下:

*   ActivityStarted:当活动开始时，会发出一行输出，其中包含 TraceID、活动在其中运行的微服务的名称、缩写的活动名称、当前的“活动向量”和事件消息文本。例如，如果发生 StartTrackingEvent，可能会发出如下所示的日志记录行:

    16 f 25 a 17d 5d 13 aa 0ba 726 a 19 a0d 9801 a 4 | CortanaTimeToLeaveService | StTrkEvnt | RegForTTL > StTrkEvnt | activity started:Attempt = 1

    活动向量使用缩写的活动名称来提供系统中端点活动内包含的各种活动的嵌套的紧凑逻辑调用栈。这有助于理解系统的流程，并允许进行强大的分析，我们将在后面看到。正如您在消息文本中看到的，一些活动中内置了重试系统，因此如果某次尝试由于某种原因失败，它们会自动尝试重新执行代码，并且消息中会跟踪重试次数。

*   ActivitySucceeded:当活动成功完成时，将发出一行输出，其中包含 TraceID、活动在其中运行的微服务的名称、缩写的活动名称、当前的“活动向量”以及事件消息文本。例如，如果 StartTrackingEvent 成功完成，将会发出如下所示的日志记录行:

    16 f 25 a 17d 5d 13 aa 0ba 726 a 19 a0d 9801 a 4 | CortanaTimeToLeaveService | StTrkEvnt | RegForTTL > StTrkEvnt | activity succeeded:持续时间=330，尝试次数=1

*   在这种情况下，请注意，活动的端到端持续时间是从它开始到完成被跟踪的，在这种情况下用了 330 微秒。

*   ActivityFailed:如果活动由于某种原因失败，将发出一行输出，其中包含 TraceID、活动在其中运行的微服务的名称、缩写的活动名称、当前的“活动向量”，以及包含异常详细信息和错误消息的事件消息文本。例如，如果 StartTrackingEvent 在执行过程中引发异常，将会发出如下所示的日志记录行:

    16 f 25 a 17d 5d 13 aa 0ba 726 a 19 a0d 9801 a 4 | cortanaimetoleaveservice | StTrkEvnt | RegForTTL > StTrkEvnt | activity failed:duration = 320，Attempt=1，Exception =空引用“register.cs”行 239 中的异常

    在这种情况下，请注意报告的错误详细信息有助于开发人员了解系统中的错误和位置。

*   除了“ActivityStarted”、“ActivitySucceeded”和“ActivityFailed”这三个基本消息之外，还可以将自定义消息发送到跟踪中。这些消息将以相同的基本格式存储，包括相关 ID、活动名称、活动向量和消息；但是在这种情况下，消息将是开发人员定义的自定义日志消息。

### 用于分析跟踪的 Azure 数据浏览器

真正让这个系统强大的是 Azure Data Explorer 的加入。Azure Data Explorer 是一个日志分析云平台，针对半结构化文本日志的即席大数据查询进行了优化。系统中由活动日志创建的所有日志都被输入到 Azure Data Explorer 中。使用 Azure Data Explorer，您可以对活动发出的整个日志集进行复杂的即席查询。例如，您可以查看任意一组至少有一个嵌套级别的活动日志，查询如下:

![../images/473932_1_En_7_Chapter/473932_1_En_7_Figa_HTML.jpg](../images/473932_1_En_7_Chapter/473932_1_En_7_Figa_HTML.jpg)

您还可以使用 Azure Data Explorer 进行更复杂的聚合查询。在本例中，我们使用 Azure Data Explorer 来确定系统中发生的常见活动向量的性能特征(GetStiCrts > UpdStiCrts)。在这种情况下，Azure Data Explorer 利用我们在每个活动成功事件的消息中一致发出“duration=”这一事实，并使用其“summarize”功能来计算整个系统中特定活动序列的性能百分比(GetStiCrts 必须在系统中获取一些所需的证书)。

![../images/473932_1_En_7_Chapter/473932_1_En_7_Figb_HTML.jpg](../images/473932_1_En_7_Chapter/473932_1_En_7_Figb_HTML.jpg)

使用基于活动的日志记录彻底覆盖您的代码，并使用 Azure Data Explorer 来分析日志记录，这是一个强大的组合，它真正允许您以多种方式测量工作软件的进度。如果你还没有使用过 Azure Data Explorer，准备好大吃一惊吧——这是一个非常强大的工具，当你开始意识到对你的监控数据进行特定和聚合查询的力量时，它将彻底改变你对衡量你的产品的看法。更多关于 Azure 数据浏览器的信息可以在 aka.ms/kdocs.获得

### Azure 数据浏览器与数据库

你可能想知道为什么要在另一个数据库上使用 Azure Data Explorer。Azure Data Explorer 擅长的是对万亿字节的半结构化文本数据进行快速查询。你还可以考虑的类似产品包括 Splunk、Logstash、InfluxDB 或 Elasticsearch。

## 监控能告诉你什么

有了基于活动的监控和 Azure Data Explorer 这样的系统来查询生成的日志数据，您现在可以真正衡量您的产品了。这里是一些你想要深入并开始创建 Azure Data Explorer 查询以在你的产品中进行分析的领域。

### 工作软件真的是工作软件吗？

基于活动的监控的一个直接好处是，您现在可以量化系统成功的频率和失败的频率。这当然会受到活动监控中的错误或缺口的影响，因此要将它作为常规的优先事项和持续集成过程的一部分，以确保基于活动的监控中不会出现缺口，并且随着新功能添加到系统中，会定义新的活动来跟踪该功能。评估系统的健康状况只需要一个 Azure Data Explorer 查询。您可以创建一个 Azure Data Explorer 查询，告诉您某项活动在过去一天中失败了多少次——类似这样:在本例中，我们基于活动的事件存储在一个名为“traceevent”的 Azure Data Explorer 表中:

```py
traceevent
| where EventInfo_Time > ago(1d)
| where Message startswith "ActivityFailed"
| count

```

您可以将它放在有多少活动通过类似的查询成功的上下文中:

```py
traceevent
| where EventInfo_Time > ago(1d)
| where Message startswith "ActivitySucceeded"
| count

```

您可以深入研究单个故障，以及像这样的查询出了什么问题:

```py
traceevent
| where EventInfo_Time > ago(1d)
| where Message startswith "ActivityFailed"
| take 5

```

### 哪里出了问题？

您可以深入研究单个故障，以及像这样的查询出了什么问题:

```py
traceevent
| where EventInfo_Time > ago(1d)
| where Message startswith "ActivityFailed"
| take 5

```

这将显示五个最近的故障。您可以从失败中获取 TraceID，并使用 Azure Data Explorer 查询查看会话期间发生的一整套活动，如下所示:

```py
traceevent
| where TraceID == "paste the entire TraceID from a failure here"
| project TraceID, ServiceID, ActivityName, ActivityVector, Message

```

这将输出一整套带有活动向量的活动跟踪，以便您可以探索故障发生前发生的事件的确切顺序。

### 有多快？

正如我们前面所看到的，您可以检查一个特定的活动向量或入口点，并使用这样的查询来查看大多数用户需要多长时间:

```py
traceevent
| where EventInfo_Time > ago(7d)
| where ActivityVector == "RegForTTL > StTrkEvnt"
| where message startswith "ActivitySucceeded"
| extend duration = extract("ActivitySucceeded: Duration=(.*?),", 1, Message, typeof(int))
| summarize percentiles(duration, 50, 75, 90, 95, 99) by bin(EventInfo_Time, 5m)

```

您可以使用这样的查询查看一组相对于其他活动花费了特别长时间的活动(观察到前一个查询中的最高时间在 500 毫秒范围内):

```py
traceevent
| where EventInfo_Time > ago(7d)
| where ActivityVector == "RegForTTL > StTrkEvnt"
| where message startswith "ActivitySucceeded"
| extend duration = extract("ActivitySucceeded: Duration=(.*?),", 1, Message, typeof(int))
| where duration > 500

```

如果您怀疑较慢的时间是由于某个特定问题而发生的，例如，如果某个事件是重复发生的事件，那么跟踪该事件的速度可能会变慢，您可以在日志中添加一个类似“recurring event”的自定义消息，然后构造一个新的查询来查找它。请注意，这假定您的基于活动的日志记录实现在记录自定义事件时也发出持续时间:

```py
traceevent
| where EventInfo_Time > ago(7d)
| where ActivityVector == "RegForTTL > StTrkEvnt"
| where message startswith "RecurringEvent"
| extend duration = extract("RecurringEvent: Duration=(.*?),", 1, Message, typeof(int))
| where duration > 500

```

### 业务目标真的实现了吗？

作为监控设计的一部分，您应该评估您将跟踪哪些业务指标来评估一个成功的项目。一个常用的业务指标是月活跃用户数。我们对离开时间 MAU 的定义是主动注册接收通知的用户数量。这个数字被证明对企业来说有些无意义，因为通过监控系统很快发现，打开该功能的人数远远多于收到离开时间通知的人数。用户没有收到通知的常见原因是:他们没有在日历上输入足够的会议位置，他们的日历上没有太多会议，或者所有会议都接近他们已经所在的位置。

因此，定义第二个指标——MEU(发音像猫会说的)是一个很好的商业实践。MEU 是一个按月付费的用户。有很多方法可以定义这个指标，但是在 Time to Leave 系统中，我们认为一个参与的用户在过去的一个月中至少收到了一个来自系统的会议提醒。跟踪通知发送的活动称为“发送通知”或“发送通知”计算上个月发送了多少个 TTL 通知的查询如下所示:

```py
traceevent
| where EventInfo_Time > ago(30d)
| where ActivityVector == "SendTTLNotification"
| where message startswith "ActivitySucceeded"
| count

```

当然，这个查询没有衡量每月参与的用户，因为一个用户可能在一个月内收到多个通知。需要更高级的查询来确定收到通知的唯一用户的数量。

确定唯一用户的数量开始进入隐私领域——很明显，系统知道用户的唯一身份，但我们不希望这种知识暴露在日志中，因为这意味着关于用户的信息可能泄露给开发人员，他们不应该能够进行 Azure Data Explorer 查询并确定任何单个用户的唯一或私人信息，如他们的电子邮件地址、会议名称或地点等。因此，为了识别用户，将使用单向散列算法来存储唯一的用户 ID，该 ID 是根据系统有权访问的用户的唯一标识信息计算的。然后，这个身份散列可以用来创建 Azure Data Explorer 查询，以确定一个月内不同用户的数量，而不会将任何个人身份信息泄露到日志记录系统中。

### 聚合和匿名

没有必要永久存储用户信息。对于我们的系统，我们将在大约 30 天后清除系统中关于用户的任何日志数据。我们将定期运行 Azure Data Explorer 查询，以存储关于关键业务指标和其他用户指标的聚合月度数据，我们希望在当前可用的日志数据中跟踪这些数据，并将聚合信息存储更长时间。

### 客户的需求真的得到满足了吗？

监控也是确定客户需求是否真正得到满足的有效方法，如果没有，为什么没有得到满足。通过监控和日志记录，我们能够确定我们的许多用户体验离开时间功能的时间之一是当他们有航班离开机场时。这让我们很惊讶，因为我们从来没有做任何特殊的工作来优先考虑这个问题。但是我们发现，机场警报经常发生，它们对用户毫无用处——机场警报的发送方式是让用户在航班起飞前 10 分钟到达机场。

当我们调查为什么这种类型的警报如此频繁地发生时，我们在一个相关系统中发现了一个意想不到的乘数。Cortana 有一个系统，当它检测到你在收件箱中收到航班确认电子邮件时，会自动将航班会议添加到你的日历中。Cortana 创建了带有机场地址的飞行会议。所以现在我们明白了为什么人们的日历上有这么多这样的会议，导致有时间留下通知。

然后，我们与构建自动创建这些会议的推理系统的团队合作，以便我们可以将这些会议识别为飞行。然后我们修改了我们的系统，在航班起飞前 2 小时向用户发出警报。

### 数据和模型是如何使用的？

考虑监视您的系统生成并呈现给客户的数据以及在生产中运行的模型的方法也是有用的。通过有效的监控，我们可以学到很多重要的东西。

我们在 Bing 的本地数据团队中收集的一个令人惊讶的有用数据是，我们记录了某个特定业务实际上向用户显示的频率。我们将记录本地数据实体每次显示在搜索结果页面上、每次显示为页面顶部答案、每次显示在地图中、每次显示本地数据实体的详细描述等等。这给了我们一个很好的想法，哪些企业实际上是由我们的搜索引擎显示和浮出水面的。密切监控企业展示的频率有助于我们跟踪用户最关心的企业类型。我们能够确定哪些类型的企业被搜索得最多，并在这些类别中进行投资。例如，我们有一个查看次数最多的类别的内部列表，我们根据最常被搜索和显示的类别来决定我们的工作重点。我们还会跟踪逐月增长最快的类别。例如，这促使我们在某一年食品卡车类别快速增长时，将该类别作为重点。

监控哪些商家被显示以及商家被显示的频率也有助于我们发现网站中的问题。我们可以一个月一个月地跟踪系统中哪些实体获得了大量的视图，突然的变化会被标记出来以供审查。通过监控实体的显示次数，我们发现一个经常被浏览的实体——拉斯维加斯的一家赌场——突然从每月数万次浏览变成了没有浏览。经过调查，我们发现我们的合并系统比一家同名餐馆的赌场更胜一筹，因此赌场已经完全从我们的系统中消失了。我们还可以通过跟踪可疑实体来检测系统的滥用，这些可疑实体从零视图开始，并开始每月积累成千上万的视图。这些有时是提交给我们的欺诈性业务，并通过了验证过程。

通常，机器学习模型将在生产中运行，必须仔细监控其性能的变化。典型的例子是设计用来检测欺诈的模型，从而在问题空间中建立了与外部坏人的敌对关系。坏人想弄清楚如何绕过欺诈检测模型，欺骗系统。监控一段时间内模型检测到的欺诈交易的数量，以及它确定的不包括欺诈的交易的数量，这一点很重要。如果好交易与欺诈交易的比率在几个月内发生显著变化，这不太可能是世界上邪恶减少和欺诈消失的结果。更有可能的是，坏演员已经找到了新的方法来击败这个系统。受对手影响的模型需要监控，并经常进行再培训和增强。

## 结论

在第 7 章“监控”中，我们讨论了如何使用基于活动的监控来真实地测量你的工作软件。我们将把这一敏捷原则改写为“对工作软件和数据的监控提供了主要的进展度量。”我们讨论了基于活动的监控系统是如何工作的，以及它记录和跟踪的内容种类。我们讨论了 Azure Data Explorer，它允许您对大量日志数据进行复杂的即席查询。我们研究了良好的监控可以告诉您的各种事情:关于您的软件是否真的如预期一样工作，关于软件为什么以及何时出现故障，关于用户从您的系统中实际体验到的性能，关于业务目标是否达到，关于客户的需求是否得到满足，以及关于如何在生产中监控数据和机器学习模型。

在第 [8](08.html) 章“可持续发展”中，我们将讨论如何确定你的工作速度是太快还是太慢，以及如何上下调整节奏。我们还将讨论目标设定和保持团队高度参与。